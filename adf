[1mdiff --git a/.env.template b/.env.template[m
[1mindex de2cd4d..865d574 100644[m
[1m--- a/.env.template[m
[1m+++ b/.env.template[m
[36m@@ -6,7 +6,7 @@[m
 # =============================================================================[m
 [m
 # Discord Bot Token - Get from https://discord.com/developers/applications[m
[31m-DISCORD_TOKEN=your_discord_bot_token_here[m
[32m+[m[32mDISCORD_TOKEN=MTM5MDE3NzE5OTczODQ1ODE3Mg.GfFZ0U.pc8IChv23_u4egRsyazUVmACY1qSAbb0ikHl2A[m
 [m
 # CRCON API Key - Get from your CRCON web interface[m
 CRCON_API_KEY=your_crcon_api_key_here[m
[1mdiff --git a/=3.10.5 b/=3.10.5[m
[1mnew file mode 100644[m
[1mindex 0000000..87d19f1[m
[1m--- /dev/null[m
[1m+++ b/=3.10.5[m
[36m@@ -0,0 +1,10 @@[m
[32m+[m[32mDefaulting to user installation because normal site-packages is not writeable[m
[32m+[m[32mRequirement already satisfied: aiohttp in c:\users\gbone\appdata\roaming\python\python313\site-packages (3.12.15)[m
[32m+[m[32mRequirement already satisfied: aiohappyeyeballs>=2.5.0 in c:\users\gbone\appdata\roaming\python\python313\site-packages (from aiohttp) (2.6.1)[m
[32m+[m[32mRequirement already satisfied: aiosignal>=1.4.0 in c:\users\gbone\appdata\roaming\python\python313\site-packages (from aiohttp) (1.4.0)[m
[32m+[m[32mRequirement already satisfied: attrs>=17.3.0 in c:\users\gbone\appdata\roaming\python\python313\site-packages (from aiohttp) (25.3.0)[m
[32m+[m[32mRequirement already satisfied: frozenlist>=1.1.1 in c:\users\gbone\appdata\roaming\python\python313\site-packages (from aiohttp) (1.7.0)[m
[32m+[m[32mRequirement already satisfied: multidict<7.0,>=4.5 in c:\users\gbone\appdata\roaming\python\python313\site-packages (from aiohttp) (6.6.4)[m
[32m+[m[32mRequirement already satisfied: propcache>=0.2.0 in c:\users\gbone\appdata\roaming\python\python313\site-packages (from aiohttp) (0.3.2)[m
[32m+[m[32mRequirement already satisfied: yarl<2.0,>=1.17.0 in c:\users\gbone\appdata\roaming\python\python313\site-packages (from aiohttp) (1.20.1)[m
[32m+[m[32mRequirement already satisfied: idna>=2.0 in c:\users\gbone\appdata\roaming\python\python313\site-packages (from yarl<2.0,>=1.17.0->aiohttp) (3.10)[m
[1mdiff --git a/enhanced_discord_bot.backup.py b/enhanced_discord_bot.backup.py[m
[1mnew file mode 100644[m
[1mindex 0000000..a535a49[m
[1m--- /dev/null[m
[1m+++ b/enhanced_discord_bot.backup.py[m
[36m@@ -0,0 +1,1416 @@[m
[32m+[m[32m#!/usr/bin/env python3[m
[32m+[m[32m"""[m
[32m+[m[32mHLL Discord Bot with API Key CRCON Integration[m
[32m+[m[32mTime Control Focused - Win by controlling the center point longest![m
[32m+[m[32m"""[m
[32m+[m
[32m+[m[32mimport asyncio[m
[32m+[m[32mimport os[m
[32m+[m[32mimport discord[m
[32m+[m[32mimport datetime[m
[32m+[m[32mimport json[m
[32m+[m[32mimport aiohttp[m
[32m+[m[32mimport logging[m
[32m+[m[32mfrom pathlib import Path[m
[32m+[m[32mfrom dotenv import load_dotenv[m
[32m+[m[32mfrom discord.ext import commands, tasks[m
[32m+[m[32mfrom discord import app_commands[m
[32m+[m[32mfrom datetime import timezone, timedelta[m
[32m+[m
[32m+[m[32m# Set up logging[m
[32m+[m[32mlogging.basicConfig([m
[32m+[m[32m    level=logging.INFO,[m
[32m+[m[32m    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',[m
[32m+[m[32m    handlers=[[m
[32m+[m[32m        logging.StreamHandler()  # Railway captures stdout[m
[32m+[m[32m    ][m
[32m+[m[32m)[m
[32m+[m[32mlogger = logging.getLogger(__name__)[m
[32m+[m
[32m+[m[32m# Create directories if running locally (Railway handles this differently)[m
[32m+[m[32mif not os.getenv('RAILWAY_ENVIRONMENT'):[m
[32m+[m[32m    for directory in ['logs', 'match_reports', 'match_data', 'backups']:[m
[32m+[m[32m        os.makedirs(directory, exist_ok=True)[m
[32m+[m
[32m+[m[32mload_dotenv()[m
[32m+[m
[32m+[m[32mintents = discord.Intents.default()[m
[32m+[m[32mintents.message_content = False[m
[32m+[m[32mbot = commands.Bot(command_prefix="!", intents=intents)[m
[32m+[m
[32m+[m[32mclocks = {}[m
[32m+[m[32mLOG_CHANNEL_ID = int(os.getenv('LOG_CHANNEL_ID', '0')) if os.getenv('LOG_CHANNEL_ID', '0').isdigit() else 0[m
[32m+[m[32mRESULTS_TARGET = None  # Will store channel/thread ID for results[m
[32m+[m
[32m+[m[32mclass APIKeyCRCONClient:[m
[32m+[m[32m    """CRCON client using API key authentication"""[m
[32m+[m[41m    [m
[32m+[m[32m    def __init__(self):[m
[32m+[m[32m        self.base_url = os.getenv('CRCON_URL', 'http://localhost:8010')[m
[32m+[m[32m        self.api_key = os.getenv('CRCON_API_KEY')[m
[32m+[m[32m        self.session = None[m
[32m+[m[32m        self.timeout = aiohttp.ClientTimeout(total=int(os.getenv('CRCON_TIMEOUT', '15')))[m
[32m+[m[41m    [m
[32m+[m[32m    async def __aenter__(self):[m
[32m+[m[32m        """Async context manager entry"""[m
[32m+[m[32m        headers = {[m
[32m+[m[32m            'Authorization': f'Bearer {self.api_key}',[m
[32m+[m[32m            'Content-Type': 'application/json',[m
[32m+[m[32m            'Accept': 'application/json'[m
[32m+[m[32m        }[m
[32m+[m[41m        [m
[32m+[m[32m        self.session = aiohttp.ClientSession([m
[32m+[m[32m            timeout=self.timeout,[m
[32m+[m[32m            headers=headers[m
[32m+[m[32m        )[m
[32m+[m[41m        [m
[32m+[m[32m        # Test connection[m
[32m+[m[32m        try:[m
[32m+[m[32m            async with self.session.get(f"{self.base_url}/api/get_status") as response:[m
[32m+[m[32m                if response.status != 200:[m
[32m+[m[32m                    await self.session.close()[m
[32m+[m[32m                    raise Exception(f"CRCON connection failed: {response.status}")[m
[32m+[m[32m        except Exception as e:[m
[32m+[m[32m            if self.session:[m
[32m+[m[32m                await self.session.close()[m
[32m+[m[32m            raise e[m
[32m+[m[41m        [m
[32m+[m[32m        logger.info("Successfully connected to CRCON with API key")[m
[32m+[m[32m        return self[m
[32m+[m[41m    [m
[32m+[m[32m    async def __aexit__(self, exc_type, exc_val, exc_tb):[m
[32m+[m[32m        """Async context manager exit"""[m
[32m+[m[32m        if self.session:[m
[32m+[m[32m            await self.session.close()[m
[32m+[m[41m    [m
[32m+[m[32m    async def get_live_game_state(self):[m
[32m+[m[32m        """Get comprehensive live game state"""[m
[32m+[m[32m        try:[m
[32m+[m[32m            # Get data concurrently[m
[32m+[m[32m            tasks = [[m
[32m+[m[32m                self._get_endpoint('/api/get_gamestate'),[m
[32m+[m[32m                self._get_endpoint('/api/get_team_view'),[m
[32m+[m[32m                self._get_endpoint('/api/get_map'),[m
[32m+[m[32m                self._get_endpoint('/api/get_players')[m
[32m+[m[32m            ][m
[32m+[m[41m            [m
[32m+[m[32m            results = await asyncio.gather(*tasks, return_exceptions=True)[m
[32m+[m[41m            [m
[32m+[m[32m            # Process results safely[m
[32m+[m[32m            game_state = results[0] if not isinstance(results[0], Exception) else {}[m
[32m+[m[32m            team_view = results[1] if not isinstance(results[1], Exception) else {}[m
[32m+[m[32m            map_info = results[2] if not isinstance(results[2], Exception) else {}[m
[32m+[m[32m            players = results[3] if not isinstance(results[3], Exception) else {}[m
[32m+[m[41m            [m
[32m+[m[32m            return {[m
[32m+[m[32m                'game_state': game_state,[m
[32m+[m[32m                'team_view': team_view,[m
[32m+[m[32m                'map_info': map_info,[m
[32m+[m[32m                'players': players,[m
[32m+[m[32m                'timestamp': datetime.datetime.now(timezone.utc)[m
[32m+[m[32m            }[m
[32m+[m[41m            [m
[32m+[m[32m        except Exception as e:[m
[32m+[m[32m            logger.error(f"Error getting game state: {e}")[m
[32m+[m[32m            return None[m
[32m+[m[41m    [m
[32m+[m[32m    async def _get_endpoint(self, endpoint):[m
[32m+[m[32m        """Helper to get data from an endpoint"""[m
[32m+[m[32m        try:[m
[32m+[m[32m            async with self.session.get(f"{self.base_url}{endpoint}") as response:[m
[32m+[m[32m                if response.status == 200:[m
[32m+[m[32m                    return await response.json()[m
[32m+[m[32m                else:[m
[32m+[m[32m                    logger.warning(f"Endpoint {endpoint} returned {response.status}")[m
[32m+[m[32m                    return {}[m
[32m+[m[32m        except Exception as e:[m
[32m+[m[32m            logger.error(f"Error getting {endpoint}: {e}")[m
[32m+[m[32m            return {}[m
[32m+[m[41m    [m
[32m+[m[32m    async def send_message(self, message: str):[m
[32m+[m[32m        """Send message to all players individually"""[m
[32m+[m[32m        try:[m
[32m+[m[32m            # First get all connected players[m
[32m+[m[32m            logger.info(f"Getting player list to send message: {message}")[m
[32m+[m[41m            [m
[32m+[m[32m            async with self.session.get(f"{self.base_url}/api/get_playerids") as response:[m
[32m+[m[32m                if response.status != 200:[m
[32m+[m[32m                    logger.warning(f"Failed to get player list: {response.status}")[m
[32m+[m[32m                    return False[m
[32m+[m[41m                [m
[32m+[m[32m                player_data = await response.json()[m
[32m+[m[32m                logger.info(f"Player data response: {player_data}")[m
[32m+[m[41m                [m
[32m+[m[32m                # Extract player list from the result[m
[32m+[m[32m                if isinstance(player_data, dict) and 'result' in player_data:[m
[32m+[m[32m                    players = player_data['result'][m
[32m+[m[32m                else:[m
[32m+[m[32m                    players = player_data[m
[32m+[m[41m                [m
[32m+[m[32m                if not players:[m
[32m+[m[32m                    logger.info("No players online to send message to")[m
[32m+[m[32m                    return True[m
[32m+[m[41m                [m
[32m+[m[32m                success_count = 0[m
[32m+[m[32m                total_players = len(players)[m
[32m+[m[41m                [m
[32m+[m[32m                # Send message to each player individually[m
[32m+[m[32m                for player in players:[m
[32m+[m[32m                    try:[m
[32m+[m[32m                        # Handle both list format [name, id] and dict format[m
[32m+[m[32m                        if isinstance(player, list) and len(player) >= 2:[m
[32m+[m[32m                            player_name = player[0][m
[32m+[m[32m                            player_id = player[1][m
[32m+[m[32m                        elif isinstance(player, dict):[m
[32m+[m[32m                            player_name = player.get('name', '')[m
[32m+[m[32m                            player_id = player.get('steam_id_64', '')[m
[32m+[m[32m                        else:[m
[32m+[m[32m                            continue[m
[32m+[m[41m                        [m
[32m+[m[32m                        # Send individual message[m
[32m+[m[32m                        payload = {[m
[32m+[m[32m                            "player_name": player_name,[m
[32m+[m[32m                            "player_id": player_id,[m
[32m+[m[32m                            "message": message,[m
[32m+[m[32m                            "by": os.getenv('BOT_NAME', 'HLLTankBot')[m
[32m+[m[32m                        }[m
[32m+[m[41m                        [m
[32m+[m[32m                        async with self.session.post(f"{self.base_url}/api/message_player", json=payload) as msg_response:[m
[32m+[m[32m                            if msg_response.status == 200:[m
[32m+[m[32m                                success_count += 1[m
[32m+[m[32m                                logger.debug(f"Message sent to {player_name}")[m
[32m+[m[32m                            else:[m
[32m+[m[32m                                logger.debug(f"Failed to message {player_name}: {msg_response.status}")[m
[32m+[m[41m                                [m
[32m+[m[32m                    except Exception as e:[m
[32m+[m[32m                        logger.debug(f"Error messaging individual player: {e}")[m
[32m+[m[32m                        continue[m
[32m+[m[41m                [m
[32m+[m[32m                logger.info(f"Message sent to {success_count}/{total_players} players")[m
[32m+[m[32m                return success_count > 0[m
[32m+[m[41m                [m
[32m+[m[32m        except Exception as e:[m
[32m+[m[32m            logger.error(f"Error sending message to all players: {e}")[m
[32m+[m[32m            return False[m
[32m+[m
[32m+[m[32mclass ClockState:[m
[32m+[m[32m    """Enhanced clock state with live updating team times"""[m
[32m+[m[41m    [m
[32m+[m[32m    def __init__(self):[m
[32m+[m[32m        self.time_a = 0.0  # Explicitly use floats[m
[32m+[m[32m        self.time_b = 0.0[m
[32m+[m[32m        self.active = None[m
[32m+[m[32m        self.last_switch = None[m
[32m+[m[32m        self.match_start_time = None[m
[32m+[m[32m        self.countdown_end = None  # Add this back[m
[32m+[m[32m        self.message = None[m
[32m+[m[32m        self.started = False[m
[32m+[m[32m        self.clock_started = False[m
[32m+[m[41m        [m
[32m+[m[32m        # CRCON integration[m
[32m+[m[32m        self.crcon_client = None[m
[32m+[m[32m        self.game_data = None[m
[32m+[m[32m        self.auto_switch = False[m
[32m+[m[32m        self.last_scores = {'allied': 0, 'axis': 0}[m
[32m+[m[32m        self.switches = [][m
[32m+[m[32m        self.last_update = None[m
[32m+[m[41m        [m
[32m+[m[32m        logger.info("ClockState initialized with time_a=0.0, time_b=0.0")[m
[32m+[m
[32m+[m[32m    def get_time_remaining(self):[m
[32m+[m[32m        """Get time remaining in match"""[m
[32m+[m[32m        if self.countdown_end:[m
[32m+[m[32m            now = datetime.datetime.now(timezone.utc)[m
[32m+[m[32m            remaining = (self.countdown_end - now).total_seconds()[m
[32m+[m[32m            return max(0, int(remaining))[m
[32m+[m[32m        return 4500  # Default 1h 15m[m
[32m+[m
[32m+[m[32m    def get_current_elapsed(self):[m
[32m+[m[32m        """Get elapsed time since last switch"""[m
[32m+[m[32m        if self.last_switch and self.clock_started and self.active:[m
[32m+[m[32m            elapsed = (datetime.datetime.now(timezone.utc) - self.last_switch).total_seconds()[m
[32m+[m[32m            # Only cap if it's truly abnormal (more than 4 hours in one session)[m
[32m+[m[32m            if elapsed > 14400:  # 4 hours[m
[32m+[m[32m                logger.error(f"Abnormal elapsed time detected: {elapsed} seconds. Resetting to 0.")[m
[32m+[m[32m                return 0[m
[32m+[m[32m            return max(0, elapsed)[m
[32m+[m[32m        return 0[m
[32m+[m
[32m+[m[32m    def total_time(self, team):[m
[32m+[m[32m        """Get total time for a team INCLUDING current elapsed time"""[m
[32m+[m[32m        if team == "A":[m
[32m+[m[32m            base_time = self.time_a[m
[32m+[m[32m            # Add current elapsed time if Allies are currently active[m
[32m+[m[32m            if self.active == "A" and self.clock_started:[m
[32m+[m[32m                current_elapsed = self.get_current_elapsed()[m
[32m+[m[32m                base_time += current_elapsed[m
[32m+[m[32m            return max(0, base_time)[m
[32m+[m[32m        elif team == "B":[m
[32m+[m[32m            base_time = self.time_b[m
[32m+[m[32m            # Add current elapsed time if Axis are currently active[m
[32m+[m[32m            if self.active == "B" and self.clock_started:[m
[32m+[m[32m                current_elapsed = self.get_current_elapsed()[m
[32m+[m[32m                base_time += current_elapsed[m
[32m+[m[32m            return max(0, base_time)[m
[32m+[m[32m        return 0[m
[32m+[m
[32m+[m[32m    def get_live_status(self, team):[m
[32m+[m[32m        """Get live status with current timing info"""[m
[32m+[m[32m        total = self.total_time(team)[m
[32m+[m[41m        [m
[32m+[m[32m        if self.active == team and self.clock_started:[m
[32m+[m[32m            # Currently active - they're defending the point they control[m
[32m+[m[32m            current_elapsed = self.get_current_elapsed()[m
[32m+[m[32m            return {[m
[32m+[m[32m                'total_time': total,[m
[32m+[m[32m                'status': 'üõ°Ô∏è Defending',[m
[32m+[m[32m                'current_session': current_elapsed,[m
[32m+[m[32m                'is_active': True[m
[32m+[m[32m            }[m
[32m+[m[32m        else:[m
[32m+[m[32m            # Not active - they're trying to attack and take the point[m
[32m+[m[32m            return {[m
[32m+[m[32m                'total_time': total,[m
[32m+[m[32m                'status': '‚öîÔ∏è Attacking',[m
[32m+[m[32m                'current_session': 0,[m
[32m+[m[32m                'is_active': False[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m    async def connect_crcon(self):[m
[32m+[m[32m        """Connect to CRCON with API key"""[m
[32m+[m[32m        try:[m
[32m+[m[32m            # Close any existing connection first[m
[32m+[m[32m            if self.crcon_client:[m
[32m+[m[32m                try:[m
[32m+[m[32m                    await self.crcon_client.__aexit__(None, None, None)[m
[32m+[m[32m                except:[m
[32m+[m[32m                    pass[m
[32m+[m[41m            [m
[32m+[m[32m            self.crcon_client = APIKeyCRCONClient()[m
[32m+[m[32m            await self.crcon_client.__aenter__()[m
[32m+[m[32m            logger.info("Connected to CRCON successfully")[m
[32m+[m[32m            return True[m
[32m+[m[32m        except Exception as e:[m
[32m+[m[32m            logger.error(f"Failed to connect to CRCON: {e}")[m
[32m+[m[32m            self.crcon_client = None[m
[32m+[m[32m            return False[m
[32m+[m[41m    [m
[32m+[m[32m    async def update_from_game(self):[m
[32m+[m[32m        """Update from CRCON game data"""[m
[32m+[m[32m        if not self.crcon_client:[m
[32m+[m[32m            return[m
[32m+[m[41m        [m
[32m+[m[32m        try:[m
[32m+[m[32m            live_data = await self.crcon_client.get_live_game_state()[m
[32m+[m[32m            if not live_data:[m
[32m+[m[32m                return[m
[32m+[m[41m            [m
[32m+[m[32m            self.game_data = live_data[m
[32m+[m[32m            self.last_update = datetime.datetime.now(timezone.utc)[m
[32m+[m[41m            [m
[32m+[m[32m            # Only check for auto-switch if we have previous scores to compare[m
[32m+[m[32m            # This prevents false triggers on first connection[m
[32m+[m[32m            if self.auto_switch and self.started and hasattr(self, '_first_update_done'):[m
[32m+[m[32m                await self._check_score_changes()[m
[32m+[m[32m            else:[m
[32m+[m[32m                # First update - just store the scores without triggering auto-switch[m
[32m+[m[32m                game_state = self.game_data.get('game_state', {})[m
[32m+[m[32m                if isinstance(game_state, dict) and 'result' in game_state:[m
[32m+[m[32m                    result = game_state['result'][m
[32m+[m[32m                    if isinstance(result, dict):[m
[32m+[m[32m                        self.last_scores = {[m
[32m+[m[32m                            'allied': result.get('allied_score', 0),[m
[32m+[m[32m                            'axis': result.get('axis_score', 0)[m
[32m+[m[32m                        }[m
[32m+[m[32m                self._first_update_done = True[m
[32m+[m[41m                [m
[32m+[m[32m        except Exception as e:[m
[32m+[m[32m            logger.error(f"Error updating from game: {e}")[m
[32m+[m[41m    [m
[32m+[m[32m    async def _check_score_changes(self):[m
[32m+[m[32m        """Check for captures to trigger auto-switch - focus on point control"""[m
[32m+[m[32m        if not self.game_data or 'game_state' not in self.game_data:[m
[32m+[m[32m            return[m
[32m+[m[41m        [m
[32m+[m[32m        game_state = self.game_data['game_state'][m
[32m+[m[41m        [m
[32m+[m[32m        # Parse your CRCON's result format for scores[m
[32m+[m[32m        current_allied = 0[m
[32m+[m[32m        current_axis = 0[m
[32m+[m[41m        [m
[32m+[m[32m        if isinstance(game_state, dict) and 'result' in game_state:[m
[32m+[m[32m            result = game_state['result'][m
[32m+[m[32m            if isinstance(result, dict):[m
[32m+[m[32m                current_allied = result.get('allied_score', 0)[m
[32m+[m[32m                current_axis = result.get('axis_score', 0)[m
[32m+[m[41m        [m
[32m+[m[32m        # Debug logging to see what's happening[m
[32m+[m[32m        logger.info(f"Score check - Allied: {self.last_scores['allied']} -> {current_allied}, Axis: {self.last_scores['axis']} -> {current_axis}")[m
[32m+[m[41m        [m
[32m+[m[32m        # Check for score increases (point captures)[m
[32m+[m[32m        if current_allied > self.last_scores['allied']:[m
[32m+[m[32m            logger.info(f"Allied score increased! Switching to Allies")[m
[32m+[m[32m            await self._auto_switch_to('A', "Allies captured the center point")[m
[32m+[m[32m        elif current_axis > self.last_scores['axis']:[m
[32m+[m[32m            logger.info(f"Axis score increased! Switching to Axis")[m[41m [m
[32m+[m[32m            await self._auto_switch_to('B', "Axis captured the center point")[m
[32m+[m[32m        else:[m
[32m+[m[32m            logger.debug(f"No score changes detected")[m
[32m+[m[41m        [m
[32m+[m[32m        # Update last known scores[m
[32m+[m[32m        self.last_scores = {'allied': current_allied, 'axis': current_axis}[m
[32m+[m[41m    [m
[32m+[m[32m    async def _auto_switch_to(self, team: str, reason: str = "Auto-switch"):[m
[32m+[m[32m        """Auto-switch teams with proper time tracking"""[m
[32m+[m[32m        if self.active == team:[m
[32m+[m[32m            return[m
[32m+[m[41m        [m
[32m+[m[32m        now = datetime.datetime.now(timezone.utc)[m
[32m+[m[41m        [m
[32m+[m[32m        # IMPORTANT: Update accumulated time BEFORE switching[m
[32m+[m[32m        if self.active and self.last_switch and self.clock_started:[m
[32m+[m[32m            elapsed = (now - self.last_switch).total_seconds()[m
[32m+[m[41m            [m
[32m+[m[32m            # Safeguard: Don't allow negative or unrealistic elapsed times (more than 4 hours)[m
[32m+[m[32m            if elapsed < 0 or elapsed > 14400:  # More than 4 hours[m
[32m+[m[32m                logger.error(f"Invalid elapsed time: {elapsed} seconds. Not adding to totals.")[m
[32m+[m[32m            else:[m
[32m+[m[32m                if self.active == "A":[m
[32m+[m[32m                    self.time_a += elapsed[m
[32m+[m[32m                    logger.info(f"Added {elapsed:.1f}s to Allies. Total: {self.time_a:.1f}s")[m
[32m+[m[32m                elif self.active == "B":[m
[32m+[m[32m                    self.time_b += elapsed[m
[32m+[m[32m                    logger.info(f"Added {elapsed:.1f}s to Axis. Total: {self.time_b:.1f}s")[m
[32m+[m[41m        [m
[32m+[m[32m        # Record the switch[m
[32m+[m[32m        switch_data = {[m
[32m+[m[32m            'from_team': self.active,[m
[32m+[m[32m            'to_team': team,[m
[32m+[m[32m            'timestamp': now,[m
[32m+[m[32m            'method': 'auto',[m
[32m+[m[32m            'reason': reason[m
[32m+[m[32m        }[m
[32m+[m[32m        self.switches.append(switch_data)[m
[32m+[m[41m        [m
[32m+[m[32m        # Set new active team and reset timer[m
[32m+[m[32m        self.active = team[m
[32m+[m[32m        self.last_switch = now[m
[32m+[m[41m        [m
[32m+[m[32m        # Start the clock if this is the first switch[m
[32m+[m[32m        if not self.clock_started:[m
[32m+[m[32m            self.clock_started = True[m
[32m+[m[41m        [m
[32m+[m[32m        # Send notification to game (if messaging works)[m
[32m+[m[32m        if self.crcon_client:[m
[32m+[m[32m            team_name = "Allies" if team == "A" else "Axis"[m
[32m+[m[41m            [m
[32m+[m[32m            # For game messages, use the accumulated times (not including current session)[m
[32m+[m[32m            # This prevents timing confusion during switches[m
[32m+[m[32m            allies_time = self.format_time(self.time_a)[m
[32m+[m[32m            axis_time = self.format_time(self.time_b)[m
[32m+[m[41m            [m
[32m+[m[32m            logger.info(f"Sending game message - Allies: {self.time_a}s ({allies_time}), Axis: {self.time_b}s ({axis_time})")[m
[32m+[m[41m            [m
[32m+[m[32m            await self.crcon_client.send_message(f"üîÑ {team_name} captured the center point! | Allies: {allies_time} | Axis: {axis_time}")[m
[32m+[m[41m        [m
[32m+[m[32m        # IMPORTANT: Update the Discord embed immediately[m
[32m+[m[32m        if self.message:[m
[32m+[m[32m            try:[m
[32m+[m[32m                await self.message.edit(embed=build_embed(self))[m
[32m+[m[32m                logger.info(f"Discord embed updated after auto-switch to {team}")[m
[32m+[m[32m            except Exception as e:[m
[32m+[m[32m                logger.error(f"Failed to update Discord embed: {e}")[m
[32m+[m[41m            [m
[32m+[m[32m        logger.info(f"Auto-switched to team {team}: {reason}")[m
[32m+[m[41m    [m
[32m+[m[32m    def get_game_info(self):[m
[32m+[m[32m        """Get formatted game information"""[m
[32m+[m[32m        if not self.game_data:[m
[32m+[m[32m            return {[m
[32m+[m[32m                'map': 'No Connection',[m
[32m+[m[32m                'players': 0,[m
[32m+[m[32m                'game_time': 0,[m
[32m+[m[32m                'connection_status': 'Disconnected'[m
[32m+[m[32m            }[m
[32m+[m[41m        [m
[32m+[m[32m        game_state = self.game_data.get('game_state', {})[m
[32m+[m[32m        team_view = self.game_data.get('team_view', {})[m
[32m+[m[32m        map_info = self.game_data.get('map_info', {})[m
[32m+[m[41m        [m
[32m+[m[32m        # Extract map name - handle your CRCON's result wrapper[m
[32m+[m[32m        current_map = 'Unknown'[m
[32m+[m[41m        [m
[32m+[m[32m        if isinstance(map_info, dict) and 'result' in map_info:[m
[32m+[m[32m            result = map_info['result'][m
[32m+[m[32m            if isinstance(result, dict):[m
[32m+[m[32m                # Try the pretty_name first (should be "Elsenborn Ridge Warfare")[m
[32m+[m[32m                if 'pretty_name' in result:[m
[32m+[m[32m                    current_map = result['pretty_name'][m
[32m+[m[32m                # Fallback to nested map object[m
[32m+[m[32m                elif 'map' in result and isinstance(result['map'], dict):[m
[32m+[m[32m                    current_map = result['map'].get('pretty_name', result['map'].get('name', 'Unknown'))[m
[32m+[m[41m        [m
[32m+[m[32m        # Extract player count from your CRCON result format[m
[32m+[m[32m        player_count = 0[m
[32m+[m[32m        if isinstance(game_state, dict) and 'result' in game_state:[m
[32m+[m[32m            result = game_state['result'][m
[32m+[m[32m            if isinstance(result, dict):[m
[32m+[m[32m                # Your format shows num_allied_players and num_axis_players[m
[32m+[m[32m                allied_players = result.get('num_allied_players', 0)[m
[32m+[m[32m                axis_players = result.get('num_axis_players', 0)[m
[32m+[m[32m                player_count = allied_players + axis_players[m
[32m+[m[41m        [m
[32m+[m[32m        # Extract game time from your CRCON result format - convert to remaining time display[m
[32m+[m[32m        game_time_remaining = 0[m
[32m+[m[32m        if isinstance(game_state, dict) and 'result' in game_state:[m
[32m+[m[32m            result = game_state['result'][m
[32m+[m[32m            if isinstance(result, dict):[m
[32m+[m[32m                # Get the raw time remaining from server[m
[32m+[m[32m                raw_time = result.get('time_remaining', 0)[m
[32m+[m[32m                if raw_time > 0:[m
[32m+[m[32m                    game_time_remaining = raw_time[m
[32m+[m[41m        [m
[32m+[m[32m        # Track scores internally for auto-switch using your CRCON format[m
[32m+[m[32m        allied_score = 0[m
[32m+[m[32m        axis_score = 0[m
[32m+[m[41m        [m
[32m+[m[32m        if isinstance(game_state, dict) and 'result' in game_state:[m
[32m+[m[32m            result = game_state['result'][m
[32m+[m[32m            if isinstance(result, dict):[m
[32m+[m[32m                allied_score = result.get('allied_score', 0)[m
[32m+[m[32m                axis_score = result.get('axis_score', 0)[m
[32m+[m[41m        [m
[32m+[m[32m        # Store scores for auto-switch logic[m
[32m+[m[32m        self.last_scores = {'allied': allied_score, 'axis': axis_score}[m
[32m+[m[41m        [m
[32m+[m[32m        return {[m
[32m+[m[32m            'map': current_map,[m
[32m+[m[32m            'players': player_count,[m
[32m+[m[32m            'game_time': game_time_remaining,  # This is now the server's remaining time[m
[32m+[m[32m            'connection_status': 'Connected',[m
[32m+[m[32m            'last_update': self.last_update.strftime('%H:%M:%S') if self.last_update else 'Never'[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m    def format_time(self, secs):[m
[32m+[m[32m        """Format seconds into readable time"""[m
[32m+[m[32m        # Handle None, negative, or invalid values[m
[32m+[m[32m        if secs is None or secs < 0:[m
[32m+[m[32m            return "0:00:00"[m
[32m+[m[41m        [m
[32m+[m[32m        # Ensure we have a valid number[m
[32m+[m[32m        try:[m
[32m+[m[32m            secs = int(secs)[m
[32m+[m[32m        except (ValueError, TypeError):[m
[32m+[m[32m            logger.warning(f"Invalid time value for formatting: {secs}")[m
[32m+[m[32m            return "0:00:00"[m
[32m+[m[41m        [m
[32m+[m[32m        # Cap at reasonable maximum (24 hours)[m
[32m+[m[32m        if secs > 86400:[m
[32m+[m[32m            logger.warning(f"Capping large time value: {secs}s -> 24:00:00")[m
[32m+[m[32m            secs = 86400[m
[32m+[m[41m            [m
[32m+[m[32m        return str(datetime.timedelta(seconds=secs))[m
[32m+[m
[32m+[m[32mdef user_is_admin(interaction: discord.Interaction):[m
[32m+[m[32m    admin_role = os.getenv('ADMIN_ROLE_NAME', 'admin').lower()[m
[32m+[m[32m    return any(role.name.lower() == admin_role for role in interaction.user.roles)[m
[32m+[m
[32m+[m[32mdef build_embed(clock: ClockState):[m
[32m+[m[32m    """Build Discord embed focused on TIME CONTROL"""[m
[32m+[m[32m    embed = discord.Embed([m
[32m+[m[32m        title="üéØ üî• HLL Tank Overwatch üî• üéØ",[m
[32m+[m[32m        description="**Control the center point to win!**",[m
[32m+[m[32m        color=0x800020[m
[32m+[m[32m    )[m
[32m+[m[41m    [m
[32m+[m[32m    # Add game information[m
[32m+[m[32m    game_info = clock.get_game_info()[m
[32m+[m[41m    [m
[32m+[m[32m    # Start with map and players[m
[32m+[m[32m    embed.description += f"\nüó∫Ô∏è **Map:** {game_info['map']}\nüë• **Players:** {game_info['players']}/100"[m
[32m+[m[41m    [m
[32m+[m[32m    # Add server game time instead of match duration[m
[32m+[m[32m    if game_info['game_time'] > 0:[m
[32m+[m[32m        embed.description += f"\n‚è∞ **Server Game Time:** `{clock.format_time(game_info['game_time'])}`"[m
[32m+[m[41m    [m
[32m+[m[32m    # Get live status for both teams[m
[32m+[m[32m    allies_status = clock.get_live_status('A')[m
[32m+[m[32m    axis_status = clock.get_live_status('B')[m
[32m+[m[41m    [m
[32m+[m[32m    # Build team information focused on TIME CONTROL[m
[32m+[m[32m    allies_value = f"**Control Time:** `{clock.format_time(allies_status['total_time'])}`\n**Status:** {allies_status['status']}"[m
[32m+[m[32m    axis_value = f"**Control Time:** `{clock.format_time(axis_status['total_time'])}`\n**Status:** {axis_status['status']}"[m
[32m+[m[41m    [m
[32m+[m[32m    # Add current session info for active team[m
[32m+[m[32m    if allies_status['is_active'] and allies_status['current_session'] > 0:[m
[32m+[m[32m        allies_value += f"\n**Current Hold:** `{clock.format_time(allies_status['current_session'])}`"[m
[32m+[m[32m    elif axis_status['is_active'] and axis_status['current_session'] > 0:[m
[32m+[m[32m        axis_value += f"\n**Current Hold:** `{clock.format_time(axis_status['current_session'])}`"[m
[32m+[m[41m    [m
[32m+[m[32m    # Add time advantage calculation[m
[32m+[m[32m    time_diff = abs(allies_status['total_time'] - axis_status['total_time'])[m
[32m+[m[32m    if allies_status['total_time'] > axis_status['total_time']:[m
[32m+[m[32m        allies_value += f"\n**Advantage:** `+{clock.format_time(time_diff)}`"[m
[32m+[m[32m    elif axis_status['total_time'] > allies_status['total_time']:[m
[32m+[m[32m        axis_value += f"\n**Advantage:** `+{clock.format_time(time_diff)}`"[m
[32m+[m[41m    [m
[32m+[m[32m    embed.add_field(name="üá∫üá∏ Allies", value=allies_value, inline=False)[m
[32m+[m[32m    embed.add_field(name="üá©üá™ Axis", value=axis_value, inline=False)[m
[32m+[m[41m    [m
[32m+[m[32m    # Add current leader status[m
[32m+[m[32m    if allies_status['total_time'] > axis_status['total_time']:[m
[32m+[m[32m        leader_text = "üèÜ **Current Leader:** Allies"[m
[32m+[m[32m    elif axis_status['total_time'] > allies_status['total_time']:[m
[32m+[m[32m        leader_text = "üèÜ **Current Leader:** Axis"[m
[32m+[m[32m    else:[m
[32m+[m[32m        leader_text = "‚öñÔ∏è **Status:** Tied"[m
[32m+[m[41m    [m
[32m+[m[32m    embed.add_field(name="üéØ Point Control", value=leader_text, inline=False)[m
[32m+[m[41m    [m
[32m+[m[32m    # Footer with connection status[m
[32m+[m[32m    connection_status = f"üü¢ CRCON Connected" if clock.crcon_client else "üî¥ CRCON Disconnected"[m
[32m+[m[32m    auto_status = " | ü§ñ Auto ON" if clock.auto_switch else " | ü§ñ Auto OFF"[m
[32m+[m[41m    [m
[32m+[m[32m    footer_text = f"Match Clock by {os.getenv('BOT_AUTHOR', 'StoneyRebel')} | {connection_status}{auto_status}"[m
[32m+[m[32m    if game_info.get('last_update'):[m
[32m+[m[32m        footer_text += f" | Updated: {game_info['last_update']}"[m
[32m+[m[41m    [m
[32m+[m[32m    embed.set_footer(text=footer_text)[m
[32m+[m[32m    return embed[m
[32m+[m
[32m+[m[32mclass StartControls(discord.ui.View):[m
[32m+[m[32m    def __init__(self, channel_id):[m
[32m+[m[32m        super().__init__(timeout=None)[m
[32m+[m[32m        self.channel_id = channel_id[m
[32m+[m
[32m+[m[32m    @discord.ui.button(label="‚ñ∂Ô∏è Start Match", style=discord.ButtonStyle.success)[m
[32m+[m[32m    async def start_match(self, interaction: discord.Interaction, button: discord.ui.Button):[m
[32m+[m[32m        if not user_is_admin(interaction):[m
[32m+[m[32m            return await interaction.response.send_message("‚ùå Admin role required.", ephemeral=True)[m
[32m+[m
[32m+[m[32m        # Respond to Discord immediately to prevent timeout[m
[32m+[m[32m        await interaction.response.defer()[m
[32m+[m
[32m+[m[32m        clock = clocks[self.channel_id][m
[32m+[m[32m        clock.match_start_time = datetime.datetime.now(timezone.utc)[m
[32m+[m[32m        clock.started = True[m
[32m+[m
[32m+[m[32m        # Start the updater first[m
[32m+[m[32m        if not match_updater.is_running():[m
[32m+[m[32m            match_updater.start(self.channel_id)[m
[32m+[m
[32m+[m[32m        view = TimerControls(self.channel_id)[m
[32m+[m[41m        [m
[32m+[m[32m        # Update the embed first[m
[32m+[m[32m        await clock.message.edit(embed=build_embed(clock), view=view)[m
[32m+[m[32m        await interaction.followup.send("‚úÖ Match started! Connecting to CRCON...", ephemeral=True)[m
[32m+[m
[32m+[m[32m        # Connect to CRCON after responding to Discord[m
[32m+[m[32m        crcon_connected = await clock.connect_crcon()[m
[32m+[m[41m        [m
[32m+[m[32m        if crcon_connected:[m
[32m+[m[32m            clock.auto_switch = os.getenv('CRCON_AUTO_SWITCH', 'false').lower() == 'true'[m
[32m+[m[32m            await clock.crcon_client.send_message("üéØ HLL Tank Overwatch Match Started! Center point control timer active.")[m
[32m+[m[32m            await interaction.edit_original_response(content="‚úÖ Match started with CRCON!")[m
[32m+[m[32m        else:[m
[32m+[m[32m            await interaction.edit_original_response(content="‚úÖ Match started (CRCON connection failed)")[m
[32m+[m
[32m+[m[32m    @discord.ui.button(label="üîó Test CRCON", style=discord.ButtonStyle.secondary)[m
[32m+[m[32m    async def test_crcon(self, interaction: discord.Interaction, button: discord.ui.Button):[m
[32m+[m[32m        await interaction.response.defer(ephemeral=True)[m
[32m+[m[41m        [m
[32m+[m[32m        try:[m
[32m+[m[32m            test_client = APIKeyCRCONClient()[m
[32m+[m[32m            async with test_client as client:[m
[32m+[m[32m                live_data = await client.get_live_game_state()[m
[32m+[m[41m                [m
[32m+[m[32m                if live_data:[m
[32m+[m[32m                    game_state = live_data.get('game_state', {})[m
[32m+[m[32m                    map_info = live_data.get('map_info', {})[m
[32m+[m[32m                    embed = discord.Embed(title="üü¢ CRCON Test - SUCCESS", color=0x00ff00)[m
[32m+[m[32m                    embed.add_field(name="Status", value="‚úÖ Connected", inline=True)[m
[32m+[m[41m                    [m
[32m+[m[32m                    # Extract map name[m
[32m+[m[32m                    map_name = 'Unknown'[m
[32m+[m[32m                    if isinstance(map_info, dict):[m
[32m+[m[32m                        if 'pretty_name' in map_info:[m
[32m+[m[32m                            map_name = map_info['pretty_name'][m
[32m+[m[32m                        elif 'name' in map_info:[m
[32m+[m[32m                            map_name = map_info['name'][m
[32m+[m[32m                        elif 'map' in map_info and isinstance(map_info['map'], dict):[m
[32m+[m[32m                            map_name = map_info['map'].get('pretty_name', 'Unknown')[m
[32m+[m[41m                    [m
[32m+[m[32m                    embed.add_field(name="Map", value=map_name, inline=True)[m
[32m+[m[32m                    embed.add_field(name="Players", value=f"{game_state.get('nb_players', 0)}/100", inline=True)[m
[32m+[m[32m                else:[m
[32m+[m[32m                    embed = discord.Embed(title="üü° CRCON Test - PARTIAL", color=0xffaa00)[m
[32m+[m[32m                    embed.add_field(name="Status", value="Connected but no data", inline=False)[m
[32m+[m[41m                    [m
[32m+[m[32m        except Exception as e:[m
[32m+[m[32m            embed = discord.Embed(title="üî¥ CRCON Test - FAILED", color=0xff0000)[m
[32m+[m[32m            embed.add_field(name="Error", value=str(e)[:1000], inline=False)[m
[32m+[m[41m        [m
[32m+[m[32m        await interaction.followup.send(embed=embed, ephemeral=True)[m
[32m+[m
[32m+[m[32mclass TimerControls(discord.ui.View):[m
[32m+[m[32m    def __init__(self, channel_id):[m
[32m+[m[32m        super().__init__(timeout=None)[m
[32m+[m[32m        self.channel_id = channel_id[m
[32m+[m
[32m+[m[32m    @discord.ui.button(label="Allies", style=discord.ButtonStyle.success, emoji="üá∫üá∏")[m
[32m+[m[32m    async def switch_to_a(self, interaction: discord.Interaction, button: discord.ui.Button):[m
[32m+[m[32m        await self._switch_team(interaction, "A")[m
[32m+[m
[32m+[m[32m    @discord.ui.button(label="Axis", style=discord.ButtonStyle.secondary, emoji="üá©üá™")[m
[32m+[m[32m    async def switch_to_b(self, interaction: discord.Interaction, button: discord.ui.Button):[m
[32m+[m[32m        await self._switch_team(interaction, "B")[m
[32m+[m
[32m+[m[32m    @discord.ui.button(label="ü§ñ Auto", style=discord.ButtonStyle.secondary)[m
[32m+[m[32m    async def toggle_auto_switch(self, interaction: discord.Interaction, button: discord.ui.Button):[m
[32m+[m[32m        if not user_is_admin(interaction):[m
[32m+[m[32m            return await interaction.response.send_message("‚ùå Admin role required.", ephemeral=True)[m
[32m+[m[41m        [m
[32m+[m[32m        clock = clocks[self.channel_id][m
[32m+[m[32m        clock.auto_switch = not clock.auto_switch[m
[32m+[m[41m        [m
[32m+[m[32m        status = "enabled" if clock.auto_switch else "disabled"[m
[32m+[m[41m        [m
[32m+[m[32m        await interaction.response.defer()[m
[32m+[m[32m        await clock.message.edit(embed=build_embed(clock), view=self)[m
[32m+[m[41m        [m
[32m+[m[32m        if clock.crcon_client:[m
[32m+[m[32m            await clock.crcon_client.send_message(f"ü§ñ Auto-switch {status}")[m
[32m+[m
[32m+[m[32m    @discord.ui.button(label="üìä Stats", style=discord.ButtonStyle.secondary)[m
[32m+[m[32m    async def show_stats(self, interaction: discord.Interaction, button: discord.ui.Button):[m
[32m+[m[32m        clock = clocks[self.channel_id][m
[32m+[m[32m        await interaction.response.defer(ephemeral=True)[m
[32m+[m[41m        [m
[32m+[m[32m        if not clock.crcon_client:[m
[32m+[m[32m            return await interaction.followup.send("‚ùå CRCON not connected.", ephemeral=True)[m
[32m+[m[41m        [m
[32m+[m[32m        try:[m
[32m+[m[32m            await clock.update_from_game()[m
[32m+[m[32m            game_info = clock.get_game_info()[m
[32m+[m[41m            [m
[32m+[m[32m            embed = discord.Embed(title="üìä Live Match Stats", color=0x00ff00)[m
[32m+[m[32m            embed.add_field(name="üó∫Ô∏è Map", value=game_info['map'], inline=True)[m
[32m+[m[32m            embed.add_field(name="üë• Players", value=f"{game_info['players']}/100", inline=True)[m
[32m+[m[32m            embed.add_field(name="üîÑ Point Switches", value=str(len(clock.switches)), inline=True)[m
[32m+[m[41m            [m
[32m+[m[32m            # Control time breakdown[m
[32m+[m[32m            allies_time = clock.total_time('A')[m
[32m+[m[32m            axis_time = clock.total_time('B')[m
[32m+[m[32m            total_control = allies_time + axis_time[m
[32m+[m[41m            [m
[32m+[m[32m            if total_control > 0:[m
[32m+[m[32m                allies_percent = (allies_time / total_control) * 100[m
[32m+[m[32m                axis_percent = (axis_time / total_control) * 100[m
[32m+[m[41m                [m
[32m+[m[32m                embed.add_field(name="üá∫üá∏ Allies Control", value=f"{allies_percent:.1f}%", inline=True)[m
[32m+[m[32m                embed.add_field(name="üá©üá™ Axis Control", value=f"{axis_percent:.1f}%", inline=True)[m
[32m+[m[41m            [m
[32m+[m[32m            embed.add_field(name="ü§ñ Auto-Switch", value="On" if clock.auto_switch else "Off", inline=True)[m
[32m+[m[32m            embed.add_field(name="üì° Last Update", value=game_info['last_update'], inline=True)[m
[32m+[m[41m            [m
[32m+[m[32m            await interaction.followup.send(embed=embed, ephemeral=True)[m
[32m+[m[41m            [m
[32m+[m[32m        except Exception as e:[m
[32m+[m[32m            await interaction.followup.send(f"‚ùå Error: {str(e)}", ephemeral=True)[m
[32m+[m
[32m+[m[32m    @discord.ui.button(label="‚Ü∫ Reset", style=discord.ButtonStyle.primary)[m
[32m+[m[32m    async def reset_timer(self, interaction: discord.Interaction, button: discord.ui.Button):[m
[32m+[m[32m        if not user_is_admin(interaction):[m
[32m+[m[32m            return await interaction.response.send_message("‚ùå Admin role required.", ephemeral=True)[m
[32m+[m
[32m+[m[32m        old_clock = clocks[self.channel_id][m
[32m+[m[32m        if old_clock.crcon_client:[m
[32m+[m[32m            await old_clock.crcon_client.__aexit__(None, None, None)[m
[32m+[m
[32m+[m[32m        clocks[self.channel_id] = ClockState()[m
[32m+[m[32m        clock = clocks[self.channel_id][m
[32m+[m[32m        view = StartControls(self.channel_id)[m
[32m+[m
[32m+[m[32m        await interaction.response.defer()[m
[32m+[m[32m        embed = build_embed(clock)[m
[32m+[m[32m        await interaction.followup.send(embed=embed, view=view)[m
[32m+[m[32m        clock.message = await interaction.original_response()[m
[32m+[m
[32m+[m[32m    @discord.ui.button(label="‚èπÔ∏è Stop", style=discord.ButtonStyle.danger)[m
[32m+[m[32m    async def stop_timer(self, interaction: discord.Interaction, button: discord.ui.Button):[m
[32m+[m[32m        if not user_is_admin(interaction):[m
[32m+[m[32m            return await interaction.response.send_message("‚ùå Admin role required.", ephemeral=True)[m
[32m+[m
[32m+[m[32m        clock = clocks[self.channel_id][m
[32m+[m[41m        [m
[32m+[m[32m        # IMPORTANT: Finalize the current session before stopping[m
[32m+[m[32m        if clock.active and clock.last_switch:[m
[32m+[m[32m            elapsed = (datetime.datetime.now(timezone.utc) - clock.last_switch).total_seconds()[m
[32m+[m[32m            if clock.active == "A":[m
[32m+[m[32m                clock.time_a += elapsed[m
[32m+[m[32m            elif clock.active == "B":[m
[32m+[m[32m                clock.time_b += elapsed[m
[32m+[m
[32m+[m[32m        clock.active = None[m
[32m+[m[32m        clock.started = False[m
[32m+[m
[32m+[m[32m        # Send final message to game[m
[32m+[m[32m        if clock.crcon_client:[m
[32m+[m[32m            winner_msg = ""[m
[32m+[m[32m            if clock.time_a > clock.time_b:[m
[32m+[m[32m                winner_msg = "Allies controlled the center longer!"[m
[32m+[m[32m            elif clock.time_b > clock.time_a:[m
[32m+[m[32m                winner_msg = "Axis controlled the center longer!"[m
[32m+[m[32m            else:[m
[32m+[m[32m                winner_msg = "Perfect tie - equal control time!"[m
[32m+[m[41m            [m
[32m+[m[32m            await clock.crcon_client.send_message([m
[32m+[m[32m                f"üèÅ Match Complete! {winner_msg} Allies: {clock.format_time(clock.time_a)} | Axis: {clock.format_time(clock.time_b)}"[m
[32m+[m[32m            )[m
[32m+[m
[32m+[m[32m        # Create final embed[m
[32m+[m[32m        embed = discord.Embed(title="üèÅ Match Complete - Time Control Results!", color=0x800020)[m
[32m+[m[41m        [m
[32m+[m[32m        game_info = clock.get_game_info()[m
[32m+[m[32m        if game_info['connection_status'] == 'Connected':[m
[32m+[m[32m            embed.add_field(name="üó∫Ô∏è Map", value=game_info['map'], inline=True)[m
[32m+[m[32m            embed.add_field(name="üë• Players", value=f"{game_info['players']}/100", inline=True)[m
[32m+[m
[32m+[m[32m        # Final CONTROL times[m
[32m+[m[32m        embed.add_field(name="üá∫üá∏ Allies Control Time", value=f"`{clock.format_time(clock.time_a)}`", inline=False)[m
[32m+[m[32m        embed.add_field(name="üá©üá™ Axis Control Time", value=f"`{clock.format_time(clock.time_b)}`", inline=False)[m
[32m+[m[41m        [m
[32m+[m[32m        # Determine winner by TIME CONTROL[m
[32m+[m[32m        time_diff = abs(clock.time_a - clock.time_b)[m
[32m+[m[32m        if clock.time_a > clock.time_b:[m
[32m+[m[32m            winner = f"üèÜ **Allies Victory**\n*+{clock.format_time(time_diff)} control advantage*"[m
[32m+[m[32m        elif clock.time_b > clock.time_a:[m
[32m+[m[32m            winner = f"üèÜ **Axis Victory**\n*+{clock.format_time(time_diff)} control advantage*"[m
[32m+[m[32m        else:[m
[32m+[m[32m            winner = "ü§ù **Perfect Draw**\n*Equal control time*"[m
[32m+[m[41m        [m
[32m+[m[32m        embed.add_field(name="üéØ Point Control Winner", value=winner, inline=False)[m
[32m+[m[32m        embed.add_field(name="üîÑ Total Switches", value=str(len(clock.switches)), inline=True)[m
[32m+[m
[32m+[m[32m        await interaction.response.defer()[m
[32m+[m[32m        await clock.message.edit(embed=embed, view=None)[m
[32m+[m
[32m+[m[32m        # Log results[m
[32m+[m[32m        await log_results(clock, game_info)[m
[32m+[m
[32m+[m[32m    async def _switch_team(self, interaction: discord.Interaction, team: str):[m
[32m+[m[32m        if not user_is_admin(interaction):[m
[32m+[m[32m            return await interaction.response.send_message("‚ùå Admin role required.", ephemeral=True)[m
[32m+[m
[32m+[m[32m        clock = clocks[self.channel_id][m
[32m+[m[32m        now = datetime.datetime.now(timezone.utc)[m
[32m+[m
[32m+[m[32m        switch_data = {[m
[32m+[m[32m            'from_team': clock.active,[m
[32m+[m[32m            'to_team': team,[m
[32m+[m[32m            'timestamp': now,[m
[32m+[m[32m            'method': 'manual'[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        if not clock.clock_started:[m
[32m+[m[32m            # First switch - start the clock[m
[32m+[m[32m            clock.clock_started = True[m
[32m+[m[32m            clock.last_switch = now[m
[32m+[m[32m            clock.active = team[m
[32m+[m[32m            clock.switches = [switch_data][m
[32m+[m[32m        else:[m
[32m+[m[32m            # Subsequent switches - accumulate time properly[m
[32m+[m[32m            if clock.active and clock.last_switch:[m
[32m+[m[32m                elapsed = (now - clock.last_switch).total_seconds()[m
[32m+[m[41m                [m
[32m+[m[32m                # Safeguard: Don't allow negative or unrealistic elapsed times (more than 4 hours)[m
[32m+[m[32m                if elapsed < 0 or elapsed > 14400:  # More than 4 hours[m
[32m+[m[32m                    logger.error(f"Invalid elapsed time in manual switch: {elapsed} seconds. Not adding to totals.")[m
[32m+[m[32m                else:[m
[32m+[m[32m                    # Add elapsed time to the previously active team[m
[32m+[m[32m                    if clock.active == "A":[m
[32m+[m[32m                        clock.time_a += elapsed[m
[32m+[m[32m                        logger.info(f"Manual switch: Added {elapsed:.1f}s to Allies. Total: {clock.time_a:.1f}s")[m
[32m+[m[32m                    elif clock.active == "B":[m
[32m+[m[32m                        clock.time_b += elapsed[m
[32m+[m[32m                        logger.info(f"Manual switch: Added {elapsed:.1f}s to Axis. Total: {clock.time_b:.1f}s")[m
[32m+[m[41m            [m
[32m+[m[32m            # Switch to new team[m
[32m+[m[32m            clock.active = team[m
[32m+[m[32m            clock.last_switch = now[m
[32m+[m[32m            clock.switches.append(switch_data)[m
[32m+[m
[32m+[m[32m        # Send notification[m
[32m+[m[32m        if clock.crcon_client:[m
[32m+[m[32m            team_name = "Allies" if team == "A" else "Axis"[m
[32m+[m[41m            [m
[32m+[m[32m            # For game messages, use the accumulated times (not including current session)[m
[32m+[m[32m            # This prevents timing confusion during switches[m[41m  [m
[32m+[m[32m            allies_time = clock.format_time(clock.time_a)[m
[32m+[m[32m            axis_time = clock.format_time(clock.time_b)[m
[32m+[m[41m            [m
[32m+[m[32m            logger.info(f"Manual switch - Sending game message - Allies: {clock.time_a}s ({allies_time}), Axis: {clock.time_b}s ({axis_time})")[m
[32m+[m[41m            [m
[32m+[m[32m            await clock.crcon_client.send_message(f"‚öîÔ∏è {team_name} captured the center point! | Allies: {allies_time} | Axis: {axis_time}")[m
[32m+[m
[32m+[m[32m        await interaction.response.defer()[m
[32m+[m[32m        await clock.message.edit(embed=build_embed(clock), view=self)[m
[32m+[m
[32m+[m[32masync def log_results(clock: ClockState, game_info: dict):[m
[32m+[m[32m    """Log match results focused on time control"""[m
[32m+[m[32m    global RESULTS_TARGET[m
[32m+[m[41m    [m
[32m+[m[32m    # Use the configured target (thread or channel)[m
[32m+[m[32m    if RESULTS_TARGET:[m
[32m+[m[32m        target = bot.get_channel(RESULTS_TARGET)[m
[32m+[m[32m    elif LOG_CHANNEL_ID:[m
[32m+[m[32m        target = bot.get_channel(LOG_CHANNEL_ID)[m
[32m+[m[32m    else:[m
[32m+[m[32m        return  # No logging configured[m
[32m+[m[41m        [m
[32m+[m[32m    if not target:[m
[32m+[m[32m        return[m
[32m+[m[41m    [m
[32m+[m[32m    embed = discord.Embed(title="üèÅ HLL Tank Overwatch Match Complete", color=0x800020)[m
[32m+[m[32m    embed.add_field(name="üá∫üá∏ Allies Control Time", value=f"`{clock.format_time(clock.time_a)}`", inline=True)[m
[32m+[m[32m    embed.add_field(name="üá©üá™ Axis Control Time", value=f"`{clock.format_time(clock.time_b)}`", inline=True)[m
[32m+[m[41m    [m
[32m+[m[32m    # Winner by time control[m
[32m+[m[32m    if clock.time_a > clock.time_b:[m
[32m+[m[32m        winner = "üèÜ Allies"[m
[32m+[m[32m        advantage = clock.format_time(clock.time_a - clock.time_b)[m
[32m+[m[32m    elif clock.time_b > clock.time_a:[m
[32m+[m[32m        winner = "üèÜ Axis"[m
[32m+[m[32m        advantage = clock.format_time(clock.time_b - clock.time_a)[m
[32m+[m[32m    else:[m
[32m+[m[32m        winner = "ü§ù Draw"[m
[32m+[m[32m        advantage = "0:00:00"[m
[32m+[m[41m    [m
[32m+[m[32m    embed.add_field(name="Winner", value=winner, inline=True)[m
[32m+[m[32m    embed.add_field(name="Advantage", value=f"`+{advantage}`", inline=True)[m
[32m+[m[41m    [m
[32m+[m[32m    if game_info['connection_status'] == 'Connected':[m
[32m+[m[32m        embed.add_field(name="üó∫Ô∏è Map", value=game_info['map'], inline=True)[m
[32m+[m[41m    [m
[32m+[m[32m    embed.add_field(name="üîÑ Switches", value=str(len(clock.switches)), inline=True)[m
[32m+[m[32m    embed.timestamp = datetime.datetime.now(timezone.utc)[m
[32m+[m[41m    [m
[32m+[m[32m    await target.send(embed=embed)[m
[32m+[m
[32m+[m[32m# Update task - shows in-game time[m
[32m+[m[32m@tasks.loop(seconds=int(os.getenv('UPDATE_INTERVAL', '15')))[m
[32m+[m[32masync def match_updater(channel_id):[m
[32m+[m[32m    """Update match display with live game time"""[m
[32m+[m[32m    clock = clocks.get(channel_id)[m
[32m+[m[32m    if not clock or not clock.started or not clock.message:[m
[32m+[m[32m        return[m
[32m+[m
[32m+[m[32m    try:[m
[32m+[m[32m        # Update from CRCON if connected[m
[32m+[m[32m        if clock.crcon_client:[m
[32m+[m[32m            try:[m
[32m+[m[32m                await clock.update_from_game()[m
[32m+[m[32m            except Exception as e:[m
[32m+[m[32m                logger.warning(f"CRCON update failed, attempting reconnect: {e}")[m
[32m+[m[32m                # Try to reconnect if the session failed[m
[32m+[m[32m                await clock.connect_crcon()[m
[32m+[m
[32m+[m[32m        # Check if game has ended (time remaining is 0 or very low)[m
[32m+[m[32m        # Only check for auto-stop if match has been running for at least 2 minutes[m
[32m+[m[32m        # This prevents false triggers on startup[m
[32m+[m[32m        match_duration = (datetime.datetime.now(timezone.utc) - clock.match_start_time).total_seconds()[m
[32m+[m[32m        game_info = clock.get_game_info()[m
[32m+[m[41m        [m
[32m+[m[32m        if (match_duration > 120 and  # Match running for at least 2 minutes[m
[32m+[m[32m            game_info['connection_status'] == 'Connected' and[m[41m [m
[32m+[m[32m            game_info['game_time'] <= 30 and[m[41m [m
[32m+[m[32m            game_info['game_time'] > 0):  # Make sure we have valid game time data[m
[32m+[m[32m            logger.info("Game time ended, automatically stopping match")[m
[32m+[m[32m            await auto_stop_match(clock, game_info)[m
[32m+[m[32m            return[m
[32m+[m
[32m+[m[32m        # Update display with current game time[m
[32m+[m[32m        try:[m
[32m+[m[32m            await clock.message.edit(embed=build_embed(clock))[m
[32m+[m[32m        except discord.HTTPException as e:[m
[32m+[m[32m            logger.warning(f"Could not update message: {e}")[m
[32m+[m
[32m+[m[32m    except Exception as e:[m
[32m+[m[32m        logger.error(f"Error in match updater: {e}")[m
[32m+[m
[32m+[m[32masync def auto_stop_match(clock: ClockState, game_info: dict):[m
[32m+[m[32m    """Automatically stop match when game time ends"""[m
[32m+[m[32m    try:[m
[32m+[m[32m        # IMPORTANT: Finalize the current session before stopping[m
[32m+[m[32m        if clock.active and clock.last_switch:[m
[32m+[m[32m            elapsed = (datetime.datetime.now(timezone.utc) - clock.last_switch).total_seconds()[m
[32m+[m[32m            if clock.active == "A":[m
[32m+[m[32m                clock.time_a += elapsed[m
[32m+[m[32m            elif clock.active == "B":[m
[32m+[m[32m                clock.time_b += elapsed[m
[32m+[m
[32m+[m[32m        clock.active = None[m
[32m+[m[32m        clock.started = False[m
[32m+[m
[32m+[m[32m        # Send final message to game[m
[32m+[m[32m        if clock.crcon_client:[m
[32m+[m[32m            winner_msg = ""[m
[32m+[m[32m            if clock.time_a > clock.time_b:[m
[32m+[m[32m                winner_msg = "Allies controlled the center longer!"[m
[32m+[m[32m            elif clock.time_b > clock.time_a:[m
[32m+[m[32m                winner_msg = "Axis controlled the center longer!"[m
[32m+[m[32m            else:[m
[32m+[m[32m                winner_msg = "Perfect tie - equal control time!"[m
[32m+[m[41m            [m
[32m+[m[32m            await clock.crcon_client.send_message([m
[32m+[m[32m                f"üèÅ Match Complete! {winner_msg} Allies: {clock.format_time(clock.time_a)} | Axis: {clock.format_time(clock.time_b)}"[m
[32m+[m[32m            )[m
[32m+[m
[32m+[m[32m        # Create final embed[m
[32m+[m[32m        embed = discord.Embed(title="üèÅ Match Complete - Time Control Results!", color=0x800020)[m
[32m+[m[32m        embed.add_field(name="üïí End Reason", value="‚è∞ Game Time Expired", inline=False)[m
[32m+[m[41m        [m
[32m+[m[32m        if game_info['connection_status'] == 'Connected':[m
[32m+[m[32m            embed.add_field(name="üó∫Ô∏è Map", value=game_info['map'], inline=True)[m
[32m+[m[32m            embed.add_field(name="üë• Players", value=f"{game_info['players']}/100", inline=True)[m
[32m+[m
[32m+[m[32m        # Final CONTROL times[m
[32m+[m[32m        embed.add_field(name="üá∫üá∏ Allies Control Time", value=f"`{clock.format_time(clock.time_a)}`", inline=False)[m
[32m+[m[32m        embed.add_field(name="üá©üá™ Axis Control Time", value=f"`{clock.format_time(clock.time_b)}`", inline=False)[m
[32m+[m[41m        [m
[32m+[m[32m        # Determine winner by TIME CONTROL[m
[32m+[m[32m        time_diff = abs(clock.time_a - clock.time_b)[m
[32m+[m[32m        if clock.time_a > clock.time_b:[m
[32m+[m[32m            winner = f"üèÜ **Allies Victory**\n*+{clock.format_time(time_diff)} control advantage*"[m
[32m+[m[32m        elif clock.time_b > clock.time_a:[m
[32m+[m[32m            winner = f"üèÜ **Axis Victory**\n*+{clock.format_time(time_diff)} control advantage*"[m
[32m+[m[32m        else:[m
[32m+[m[32m            winner = "ü§ù **Perfect Draw**\n*Equal control time*"[m
[32m+[m[41m        [m
[32m+[m[32m        embed.add_field(name="üéØ Point Control Winner", value=winner, inline=False)[m
[32m+[m[32m        embed.add_field(name="üîÑ Total Switches", value=str(len(clock.switches)), inline=True)[m
[32m+[m
[32m+[m[32m        # Update the message with final results[m
[32m+[m[32m        await clock.message.edit(embed=embed, view=None)[m
[32m+[m[41m        [m
[32m+[m[32m        # Also post to the channel (not just edit the existing message)[m
[32m+[m[32m        channel = clock.message.channel[m
[32m+[m[32m        await channel.send("üèÅ **MATCH COMPLETE!** üèÅ", embed=embed)[m
[32m+[m
[32m+[m[32m        # Log results to log channel[m
[32m+[m[32m        await log_results(clock, game_info)[m
[32m+[m[41m        [m
[32m+[m[32m        logger.info("Match automatically stopped due to game time expiring")[m
[32m+[m
[32m+[m[32m    except Exception as e:[m
[32m+[m[32m        logger.error(f"Error in auto_stop_match: {e}")[m
[32m+[m
[32m+[m[32m# Bot commands[m
[32m+[m[32m@bot.tree.command(name="setup_results", description="Configure where match results are posted")[m
[32m+[m[32masync def setup_results(interaction: discord.Interaction,[m[41m [m
[32m+[m[32m                       channel: discord.TextChannel = None,[m[41m [m
[32m+[m[32m                       thread: discord.Thread = None):[m
[32m+[m[32m    try:[m
[32m+[m[32m        if not user_is_admin(interaction):[m
[32m+[m[32m            return await interaction.response.send_message("‚ùå Admin role required.", ephemeral=True)[m
[32m+[m[41m        [m
[32m+[m[32m        # Store the choice globally (you could also use a simple file or database)[m
[32m+[m[32m        global RESULTS_TARGET[m
[32m+[m[41m        [m
[32m+[m[32m        if thread:[m
[32m+[m[32m            RESULTS_TARGET = thread.id[m
[32m+[m[32m            await interaction.response.send_message(f"‚úÖ Match results will be posted to thread: {thread.name}", ephemeral=True)[m
[32m+[m[32m            logger.info(f"Results target set to thread: {thread.name} ({thread.id}) by {interaction.user}")[m
[32m+[m[32m        elif channel:[m
[32m+[m[32m            RESULTS_TARGET = channel.id[m
[32m+[m[32m            await interaction.response.send_message(f"‚úÖ Match results will be posted to channel: {channel.name}", ephemeral=True)[m
[32m+[m[32m            logger.info(f"Results target set to channel: {channel.name} ({channel.id}) by {interaction.user}")[m
[32m+[m[32m        else:[m
[32m+[m[32m            RESULTS_TARGET = None[m
[32m+[m[32m            await interaction.response.send_message("‚úÖ Match results posting disabled", ephemeral=True)[m
[32m+[m[32m            logger.info(f"Results posting disabled by {interaction.user}")[m
[32m+[m[41m            [m
[32m+[m[32m    except Exception as e:[m
[32m+[m[32m        logger.error(f"Error in setup_results command: {e}")[m
[32m+[m[32m        try:[m
[32m+[m[32m            await interaction.response.send_message(f"‚ùå Error setting up results: {str(e)}", ephemeral=True)[m
[32m+[m[32m        except:[m
[32m+[m[32m            pass[m
[32m+[m
[32m+[m[32m@bot.tree.command(name="reverse_clock", description="Start the HLL Tank Overwatch time control clock")[m
[32m+[m[32masync def reverse_clock(interaction: discord.Interaction):[m
[32m+[m[32m    try:[m
[32m+[m[32m        # Respond IMMEDIATELY to prevent timeout[m
[32m+[m[32m        await interaction.response.send_message("‚è≥ Creating clock...", ephemeral=True)[m
[32m+[m[41m        [m
[32m+[m[32m        channel_id = interaction.channel_id[m
[32m+[m[32m        clocks[channel_id] = ClockState()[m
[32m+[m
[32m+[m[32m        embed = build_embed(clocks[channel_id])[m
[32m+[m[32m        view = StartControls(channel_id)[m
[32m+[m
[32m+[m[32m        # Send the actual clock to the channel[m
[32m+[m[32m        posted_message = await interaction.channel.send(embed=embed, view=view)[m
[32m+[m[32m        clocks[channel_id].message = posted_message[m
[32m+[m[41m        [m
[32m+[m[32m        # Update the ephemeral message[m
[32m+[m[32m        await interaction.edit_original_response(content="‚úÖ HLL Tank Overwatch clock ready!")[m
[32m+[m[41m        [m
[32m+[m[32m        logger.info(f"Clock created successfully by {interaction.user} in channel {channel_id}")[m
[32m+[m[41m        [m
[32m+[m[32m    except Exception as e:[m
[32m+[m[32m        logger.error(f"Error in reverse_clock command: {e}")[m
[32m+[m[32m        try:[m
[32m+[m[32m            await interaction.edit_original_response(content=f"‚ùå Error creating clock: {str(e)}")[m
[32m+[m[32m        except:[m
[32m+[m[32m            try:[m
[32m+[m[32m                await interaction.followup.send(f"‚ùå Error creating clock: {str(e)}", ephemeral=True)[m
[32m+[m[32m            except:[m
[32m+[m[32m                pass[m
[32m+[m
[32m+[m[32m@bot.tree.command(name="crcon_status", description="Check CRCON connection status")[m
[32m+[m[32masync def crcon_status(interaction: discord.Interaction):[m
[32m+[m[32m    # Respond immediately[m
[32m+[m[32m    await interaction.response.send_message("üîç Checking CRCON status...", ephemeral=True)[m
[32m+[m[41m    [m
[32m+[m[32m    embed = discord.Embed(title="üîó CRCON Status", color=0x0099ff)[m
[32m+[m[41m    [m
[32m+[m[32m    try:[m
[32m+[m[32m        test_client = APIKeyCRCONClient()[m
[32m+[m[32m        async with test_client as client:[m
[32m+[m[32m            live_data = await client.get_live_game_state()[m
[32m+[m[41m            [m
[32m+[m[32m            if live_data:[m
[32m+[m[32m                game_state = live_data.get('game_state', {})[m
[32m+[m[32m                embed.add_field(name="Connection", value="‚úÖ Connected", inline=True)[m
[32m+[m[32m                embed.add_field(name="API Key", value="‚úÖ Valid", inline=True)[m
[32m+[m[32m                embed.add_field(name="Data", value="‚úÖ Available", inline=True)[m
[32m+[m[32m                embed.add_field(name="Current Map", value=game_state.get('current_map', 'Unknown'), inline=True)[m
[32m+[m[32m                embed.add_field(name="Players", value=f"{game_state.get('nb_players', 0)}/100", inline=True)[m
[32m+[m[32m                embed.add_field(name="Server Status", value="üü¢ Online", inline=True)[m
[32m+[m[32m            else:[m
[32m+[m[32m                embed.add_field(name="Connection", value="üü° Connected", inline=True)[m
[32m+[m[32m                embed.add_field(name="Data", value="‚ùå No data", inline=True)[m
[32m+[m[41m                [m
[32m+[m[32m    except Exception as e:[m
[32m+[m[32m        embed.add_field(name="Connection", value="‚ùå Failed", inline=True)[m
[32m+[m[32m        embed.add_field(name="Error", value=str(e)[:500], inline=False)[m
[32m+[m[41m    [m
[32m+[m[32m    # Configuration info[m
[32m+[m[32m    embed.add_field(name="URL", value=os.getenv('CRCON_URL', 'Not set'), inline=True)[m
[32m+[m[32m    embed.add_field(name="API Key", value=f"{os.getenv('CRCON_API_KEY', 'Not set')[:8]}..." if os.getenv('CRCON_API_KEY') else 'Not set', inline=True)[m
[32m+[m[41m    [m
[32m+[m[32m    await interaction.edit_original_response(content="", embed=embed)[m
[32m+[m
[32m+[m[32m@bot.tree.command(name="server_info", description="Get current HLL server information")[m
[32m+[m[32masync def server_info(interaction: discord.Interaction):[m
[32m+[m[32m    # Respond immediately[m
[32m+[m[32m    await interaction.response.send_message("üîç Getting server info...", ephemeral=True)[m
[32m+[m[41m    [m
[32m+[m[32m    try:[m
[32m+[m[32m        test_client = APIKeyCRCONClient()[m
[32m+[m[32m        async with test_client as client:[m
[32m+[m[32m            live_data = await client.get_live_game_state()[m
[32m+[m[41m            [m
[32m+[m[32m            if not live_data:[m
[32m+[m[32m                return await interaction.edit_original_response(content="‚ùå Could not retrieve server information")[m
[32m+[m[41m            [m
[32m+[m[32m            embed = discord.Embed(title="üéÆ HLL Server Information", color=0x00ff00)[m
[32m+[m[41m            [m
[32m+[m[32m            game_state = live_data.get('game_state', {})[m
[32m+[m[32m            map_info = live_data.get('map_info', {})[m
[32m+[m[41m            [m
[32m+[m[32m            # Extract map info[m
[32m+[m[32m            map_name = 'Unknown'[m
[32m+[m[32m            if isinstance(map_info, dict):[m
[32m+[m[32m                if 'pretty_name' in map_info:[m
[32m+[m[32m                    map_name = map_info['pretty_name'][m
[32m+[m[32m                elif 'name' in map_info:[m
[32m+[m[32m                    map_name = map_info['name'][m
[32m+[m[32m                elif 'map' in map_info and isinstance(map_info['map'], dict):[m
[32m+[m[32m                    map_name = map_info['map'].get('pretty_name', map_info['map'].get('name', 'Unknown'))[m
[32m+[m[41m            [m
[32m+[m[32m            embed.add_field(name="üó∫Ô∏è Map", value=map_name, inline=True)[m
[32m+[m[32m            embed.add_field(name="üë• Players", value=f"{game_state.get('nb_players', 0)}/100", inline=True)[m
[32m+[m[41m            [m
[32m+[m[32m            if game_state.get('time_remaining', 0) > 0:[m
[32m+[m[32m                time_remaining = game_state['time_remaining'][m
[32m+[m[32m                embed.add_field(name="‚è±Ô∏è Game Time", value=f"{time_remaining//60}:{time_remaining%60:02d}", inline=True)[m
[32m+[m[41m            [m
[32m+[m[32m            embed.timestamp = datetime.datetime.now(timezone.utc)[m
[32m+[m[32m            await interaction.edit_original_response(content="", embed=embed)[m
[32m+[m[41m            [m
[32m+[m[32m    except Exception as e:[m
[32m+[m[32m        await interaction.edit_original_response(content=f"‚ùå Error retrieving server info: {str(e)}")[m
[32m+[m
[32m+[m[32m@bot.tree.command(name="test_map", description="Quick map data test")[m
[32m+[m[32masync def test_map(interaction: discord.Interaction):[m
[32m+[m[32m    # Respond immediately[m[41m  [m
[32m+[m[32m    await interaction.response.send_message("üß™ Testing map data...", ephemeral=True)[m
[32m+[m[41m    [m
[32m+[m[32m    try:[m
[32m+[m[32m        test_client = APIKeyCRCONClient()[m
[32m+[m[32m        async with test_client as client:[m
[32m+[m[32m            live_data = await client.get_live_game_state()[m
[32m+[m[41m            [m
[32m+[m[32m            if not live_data:[m
[32m+[m[32m                return await interaction.edit_original_response(content="‚ùå No data")[m
[32m+[m[41m            [m
[32m+[m[32m            map_info = live_data.get('map_info', {})[m
[32m+[m[32m            game_state = live_data.get('game_state', {})[m
[32m+[m[41m            [m
[32m+[m[32m            msg = f"**Map Info:** {map_info}\n\n**Game State:** {game_state}"[m
[32m+[m[41m            [m
[32m+[m[32m            # Truncate if too long[m
[32m+[m[32m            if len(msg) > 1900:[m
[32m+[m[32m                msg = msg[:1900] + "..."[m
[32m+[m[41m            [m
[32m+[m[32m            await interaction.edit_original_response(content=f"```\n{msg}\n```")[m
[32m+[m[41m            [m
[32m+[m[32m    except Exception as e:[m
[32m+[m[32m        await interaction.edit_original_response(content=f"‚ùå Error: {str(e)}")[m
[32m+[m
[32m+[m[32m@bot.tree.command(name="send_message", description="Send a message to the HLL server")[m
[32m+[m[32masync def send_server_message(interaction: discord.Interaction, message: str):[m
[32m+[m[32m    if not user_is_admin(interaction):[m
[32m+[m[32m        return await interaction.response.send_message("‚ùå Admin role required.", ephemeral=True)[m
[32m+[m[41m    [m
[32m+[m[32m    # Respond immediately[m
[32m+[m[32m    await interaction.response.send_message("üì§ Sending message to server...", ephemeral=True)[m
[32m+[m[41m    [m
[32m+[m[32m    try:[m
[32m+[m[32m        test_client = APIKeyCRCONClient()[m
[32m+[m[32m        async with test_client as client:[m
[32m+[m[32m            success = await client.send_message(f"üì¢ [Discord] {message}")[m
[32m+[m[41m            [m
[32m+[m[32m            if success:[m
[32m+[m[32m                embed = discord.Embed([m
[32m+[m[32m                    title="üì¢ Message Sent",[m
[32m+[m[32m                    description=f"Successfully sent to server:\n\n*{message}*",[m
[32m+[m[32m                    color=0x00ff00[m
[32m+[m[32m                )[m
[32m+[m[32m            else:[m
[32m+[m[32m                embed = discord.Embed([m
[32m+[m[32m                    title="‚ö†Ô∏è Message Not Sent",[m
[32m+[m[32m                    description="Message endpoints not available on this CRCON version",[m
[32m+[m[32m                    color=0xffaa00[m
[32m+[m[32m                )[m
[32m+[m[41m            [m
[32m+[m[32m            await interaction.edit_original_response(content="", embed=embed)[m
[32m+[m[41m            [m
[32m+[m[32m    except Exception as e:[m
[32m+[m[32m        await interaction.edit_original_response(content=f"‚ùå Error: {str(e)}")[m
[32m+[m
[32m+[m[32m@bot.tree.command(name="test_bot", description="Test if the bot is working correctly")[m
[32m+[m[32masync def test_bot(interaction: discord.Interaction):[m
[32m+[m[32m    try:[m
[32m+[m[32m        await interaction.response.send_message("‚úÖ Bot is working! All systems operational.", ephemeral=True)[m
[32m+[m[32m        logger.info(f"Test command used successfully by {interaction.user}")[m
[32m+[m[32m    except Exception as e:[m
[32m+[m[32m        logger.error(f"Error in test_bot command: {e}")[m
[32m+[m
[32m+[m[32m@bot.tree.command(name="test_times", description="Test current time calculations (admin only)")[m
[32m+[m[32masync def test_times(interaction: discord.Interaction):[m
[32m+[m[32m    if not user_is_admin(interaction):[m
[32m+[m[32m        return await interaction.response.send_message("‚ùå Admin role required.", ephemeral=True)[m
[32m+[m[41m    [m
[32m+[m[32m    await interaction.response.send_message("üß™ Testing time calculations...", ephemeral=True)[m
[32m+[m[41m    [m
[32m+[m[32m    # Find an active clock[m
[32m+[m[32m    active_clock = None[m
[32m+[m[32m    for clock in clocks.values():[m
[32m+[m[32m        if clock.started:[m
[32m+[m[32m            active_clock = clock[m
[32m+[m[32m            break[m
[32m+[m[41m    [m
[32m+[m[32m    if not active_clock:[m
[32m+[m[32m        return await interaction.edit_original_response(content="‚ùå No active match found. Start a match first with /reverse_clock")[m
[32m+[m[41m    [m
[32m+[m[32m    try:[m
[32m+[m[32m        # Get current times[m
[32m+[m[32m        allies_accumulated = active_clock.time_a[m
[32m+[m[32m        axis_accumulated = active_clock.time_b[m
[32m+[m[32m        allies_total = active_clock.total_time('A')[m
[32m+[m[32m        axis_total = active_clock.total_time('B')[m
[32m+[m[32m        current_elapsed = active_clock.get_current_elapsed()[m
[32m+[m[41m        [m
[32m+[m[32m        # Format times[m
[32m+[m[32m        allies_acc_formatted = active_clock.format_time(allies_accumulated)[m
[32m+[m[32m        axis_acc_formatted = active_clock.format_time(axis_accumulated)[m[41m [m
[32m+[m[32m        allies_total_formatted = active_clock.format_time(allies_total)[m
[32m+[m[32m        axis_total_formatted = active_clock.format_time(axis_total)[m
[32m+[m[32m        current_elapsed_formatted = active_clock.format_time(current_elapsed)[m
[32m+[m[41m        [m
[32m+[m[32m        debug_info = f"""**Time Debug Info:**[m
[32m+[m
[32m+[m[32m**Accumulated Times:**[m
[32m+[m[32m‚Ä¢ Allies: {allies_accumulated}s ‚Üí {allies_acc_formatted}[m
[32m+[m[32m‚Ä¢ Axis: {axis_accumulated}s ‚Üí {axis_acc_formatted}[m
[32m+[m
[32m+[m[32m**Total Times (with current session):**[m
[32m+[m[32m‚Ä¢ Allies: {allies_total}s ‚Üí {allies_total_formatted}[m[41m  [m
[32m+[m[32m‚Ä¢ Axis: {axis_total}s ‚Üí {axis_total_formatted}[m
[32m+[m
[32m+[m[32m**Current Session:**[m
[32m+[m[32m‚Ä¢ Active Team: {active_clock.active or 'None'}[m
[32m+[m[32m‚Ä¢ Session Time: {current_elapsed}s ‚Üí {current_elapsed_formatted}[m
[32m+[m[32m‚Ä¢ Clock Started: {active_clock.clock_started}[m
[32m+[m
[32m+[m[32m**Game Message Would Show:**[m
[32m+[m[32m‚öîÔ∏è Test captured the center point! | Allies: {allies_acc_formatted} | Axis: {axis_acc_formatted}"""[m
[32m+[m
[32m+[m[32m        await interaction.edit_original_response(content=debug_info)[m
[32m+[m[41m        [m
[32m+[m[32m        # Also send a test message to the game server[m
[32m+[m[32m        if active_clock.crcon_client:[m
[32m+[m[32m            await active_clock.crcon_client.send_message(f"üß™ TEST MESSAGE | Allies: {allies_acc_formatted} | Axis: {axis_acc_formatted}")[m
[32m+[m[41m            [m
[32m+[m[32m    except Exception as e:[m
[32m+[m[32m        await interaction.edit_original_response(content=f"‚ùå Error testing times: {str(e)}")[m
[32m+[m
[32m+[m[32m@bot.tree.command(name="help_clock", description="Show help for the time control clock")[m
[32m+[m[32masync def help_clock(interaction: discord.Interaction):[m
[32m+[m[32m    embed = discord.Embed(title="üéØ HLL Tank Overwatch Clock Help", color=0x0099ff)[m
[32m+[m[41m    [m
[32m+[m[32m    embed.add_field([m
[32m+[m[32m        name="üìã Commands",[m
[32m+[m[32m        value=([m
[32m+[m[32m            "`/reverse_clock` - Start a new time control clock\n"[m
[32m+[m[32m            "`/setup_results` - Choose where match results are posted\n"[m
[32m+[m[32m            "`/test_bot` - Test if the bot is working\n"[m
[32m+[m[32m            "`/test_times` - Debug time calculations (admin)\n"[m
[32m+[m[32m            "`/crcon_status` - Check CRCON connection\n"[m
[32m+[m[32m            "`/server_info` - Get current server info\n"[m
[32m+[m[32m            "`/send_message` - Send message to server (admin)\n"[m
[32m+[m[32m            "`/test_map` - Test map data retrieval\n"[m
[32m+[m[32m        ),[m
[32m+[m[32m        inline=False[m
[32m+[m[32m    )[m
[32m+[m[41m    [m
[32m+[m[32m    embed.add_field([m
[32m+[m[32m        name="üéÆ How to Use",[m
[32m+[m[32m        value=([m
[32m+[m[32m            "1. Use `/reverse_clock` to create a clock\n"[m
[32m+[m[32m            "2. Click **‚ñ∂Ô∏è Start Match** to begin\n"[m
[32m+[m[32m            "3. Use **Allies**/**Axis** buttons to switch control\n"[m
[32m+[m[32m            "4. Toggle **ü§ñ Auto** for automatic switching\n"[m
[32m+[m[32m            "5. Click **‚èπÔ∏è Stop** when match ends\n"[m
[32m+[m[32m        ),[m
[32m+[m[32m        inline=False[m
[32m+[m[32m    )[m
[32m+[m[41m    [m
[32m+[m[32m    embed.add_field([m
[32m+[m[32m        name="üèÜ How to Win",[m
[32m+[m[32m        value=([m
[32m+[m[32m            "**Win by controlling the center point longer!**\n"[m
[32m+[m[32m            "‚Ä¢ Whoever holds the point accumulates time\n"[m
[32m+[m[32m            "‚Ä¢ Team with most control time wins\n"[m
[32m+[m[32m            "‚Ä¢ Captures matter, not kills or other scores"[m
[32m+[m[32m        ),[m
[32m+[m[32m        inline=False[m
[32m+[m[32m    )[m
[32m+[m[41m    [m
[32m+[m[32m    embed.add_field([m
[32m+[m[32m        name="‚öôÔ∏è Auto-Switch",[m
[32m+[m[32m        value=([m
[32m+[m[32m            "When enabled, the clock automatically switches teams "[m
[32m+[m[32m            "when point captures are detected from the game server."[m
[32m+[m[32m        ),[m
[32m+[m[32m        inline=False[m
[32m+[m[32m    )[m
[32m+[m[41m    [m
[32m+[m[32m    embed.add_field([m
[32m+[m[32m        name="üëë Admin Requirements",[m
[32m+[m[32m        value="You need the **Admin** role to control the clock.",[m
[32m+[m[32m        inline=False[m
[32m+[m[32m    )[m
[32m+[m[41m    [m
[32m+[m[32m    await interaction.response.send_message(embed=embed, ephemeral=True)[m
[32m+[m
[32m+[m[32m# Error handling[m
[32m+[m[32m@bot.event[m
[32m+[m[32masync def on_error(event, *args, **kwargs):[m
[32m+[m[32m    logger.error(f"Bot error in {event}: {args}")[m
[32m+[m
[32m+[m[32m@bot.tree.error[m
[32m+[m[32masync def on_app_command_error(interaction: discord.Interaction, error: discord.app_commands.AppCommandError):[m
[32m+[m[32m    error_msg = f"‚ùå Error: {str(error)}"[m
[32m+[m[32m    logger.error(f"Slash command error: {error} | Command: {interaction.command.name if interaction.command else 'Unknown'} | User: {interaction.user}")[m
[32m+[m[41m    [m
[32m+[m[32m    try:[m
[32m+[m[32m        if not interaction.response.is_done():[m
[32m+[m[32m            await interaction.response.send_message(error_msg, ephemeral=True)[m
[32m+[m[32m        else:[m
[32m+[m[32m            await interaction.followup.send(error_msg, ephemeral=True)[m
[32m+[m[32m    except Exception as e:[m
[32m+[m[32m        logger.error(f"Could not send error message: {e}")[m
[32m+[m
[32m+[m[32m@bot.event[m
[32m+[m[32masync def on_ready():[m
[32m+[m[32m    logger.info(f"‚úÖ Bot logged in as {bot.user}")[m
[32m+[m[32m    logger.info(f"üîó CRCON URL: {os.getenv('CRCON_URL', 'Not configured')}")[m
[32m+[m[41m    [m
[32m+[m[32m    # Test CRCON connection on startup[m
[32m+[m[32m    try:[m
[32m+[m[32m        test_client = APIKeyCRCONClient()[m
[32m+[m[32m        async with test_client as client:[m
[32m+[m[32m            live_data = await client.get_live_game_state()[m
[32m+[m[32m            if live_data:[m
[32m+[m[32m                logger.info("‚úÖ CRCON connection verified on startup")[m
[32m+[m[32m            else:[m
[32m+[m[32m                logger.warning("üü° CRCON connected but no game data")[m
[32m+[m[32m    except Exception as e:[m
[32m+[m[32m        logger.warning(f"‚ö†Ô∏è CRCON connection test failed: {e}")[m
[32m+[m[41m    [m
[32m+[m[32m    # Sync commands[m
[32m+[m[32m    await bot.wait_until_ready()[m
[32m+[m[32m    try:[m
[32m+[m[32m        synced = await bot.tree.sync()[m
[32m+[m[32m        logger.info(f"‚úÖ Synced {len(synced)} slash commands")[m
[32m+[m[32m        command_names = [cmd.name for cmd in synced][m
[32m+[m[32m        logger.info(f"Commands: {', '.join(command_names)}")[m
[32m+[m[32m        print(f"üéâ HLL Tank Overwatch Clock ready! Use /reverse_clock to start")[m
[32m+[m[32m    except Exception as e:[m
[32m+[m[32m        logger.error(f"‚ùå Command sync failed: {e}")[m
[32m+[m
[32m+[m[32m# Main execution[m
[32m+[m[32mif __name__ == "__main__":[m
[32m+[m[32m    print("üöÄ Starting HLL Tank Overwatch Bot...")[m
[32m+[m[41m    [m
[32m+[m[32m    # Check for Discord token[m
[32m+[m[32m    token = os.getenv("DISCORD_TOKEN")[m
[32m+[m[32m    if not token or token == "your_discord_bot_token_here":[m
[32m+[m[32m        print("‚ùå DISCORD_TOKEN not configured!")[m
[32m+[m[32m        print("1. Create a Discord bot at https://discord.com/developers/applications")[m
[32m+[m[32m        print("2. Copy the bot token")[m
[32m+[m[32m        print("3. Edit .env file and set DISCORD_TOKEN=your_actual_token")[m
[32m+[m[32m        exit(1)[m
[32m+[m[41m    [m
[32m+[m[32m    # Check for API key[m
[32m+[m[32m    api_key = os.getenv("CRCON_API_KEY")[m
[32m+[m[32m    if not api_key or api_key == "your_crcon_api_key_here":[m
[32m+[m[32m        print("‚ùå CRCON_API_KEY not configured!")[m
[32m+[m[32m        print("Edit .env file and set CRCON_API_KEY=your_crcon_api_key_here")[m
[32m+[m[32m        exit(1)[m
[32m+[m[41m    [m
[32m+[m[32m    # Show configuration[m
[32m+[m[32m    print(f"üîó CRCON: {os.getenv('CRCON_URL', 'http://localhost:8010')}")[m
[32m+[m[32m    print(f"üîë API Key: {api_key[:8]}...")[m
[32m+[m[32m    print(f"üëë Admin Role: {os.getenv('ADMIN_ROLE_NAME', 'admin')}")[m
[32m+[m[32m    print(f"ü§ñ Bot Name: {os.getenv('BOT_NAME', 'HLLTankBot')}")[m
[32m+[m[32m    print(f"‚è±Ô∏è Update Interval: {os.getenv('UPDATE_INTERVAL', '15')}s")[m
[32m+[m[32m    print(f"üîÑ Auto-Switch: {os.getenv('CRCON_AUTO_SWITCH', 'true')}")[m
[32m+[m[41m    [m
[32m+[m[32m    log_channel = os.getenv('LOG_CHANNEL_ID', '0')[m
[32m+[m[32m    if log_channel != '0':[m
[32m+[m[32m        print(f"üìã Log Channel: {log_channel}")[m
[32m+[m[32m    else:[m
[32m+[m[32m        print("üìã Log Channel: Disabled")[m
[32m+[m[41m    [m
[32m+[m[32m    print("üéØ Focus: TIME CONTROL - Win by holding the center point longest!")[m
[32m+[m[41m    [m
[32m+[m[32m    try:[m
[32m+[m[32m        bot.run(token)[m
[32m+[m[32m    except Exception as e:[m
[32m+[m[32m        logger.error(f"Failed to start bot: {e}")[m
[32m+[m[32m        print(f"‚ùå Bot startup failed: {e}")[m
[1mdiff --git a/enhanced_discord_bot.py b/enhanced_discord_bot.py[m
[1mindex c569387..fbe8261 100644[m
[1m--- a/enhanced_discord_bot.py[m
[1m+++ b/enhanced_discord_bot.py[m
[36m@@ -22,7 +22,9 @@[m [mimport uvicorn[m
 from discord.ext import tasks[m
 [m
 from tankscore.score_engine import ScoreEngine[m
[31m-from tankscore.webhook_server import app as webhook_app, ENGINE as WEBHOOK_ENGINE[m
[32m+[m[32mfrom tankscore.discord_ui import register_slash_commands[m
[32m+[m[32mimport tankscore.webhook_server as webhook_server[m
[32m+[m[32mwebhook_app = webhook_server.app[m
 [m
 # Set up logging[m
 logging.basicConfig([m
[36m@@ -48,6 +50,38 @@[m [mbot = commands.Bot(command_prefix="!", intents=intents)[m
 clocks = {}[m
 LOG_CHANNEL_ID = int(os.getenv('LOG_CHANNEL_ID', '0')) if os.getenv('LOG_CHANNEL_ID', '0').isdigit() else 0[m
 RESULTS_TARGET = None  # Will store channel/thread ID for results[m
[32m+[m[32m# TankScore scoreboard messages keyed by channel id[m
[32m+[m[32mTANKSCORE_SCOREBOARDS = {}  # channel_id -> discord.Message[m
[32m+[m
[32m+[m[32m# Track last seen owner per sector to avoid spamming engine[m
[32m+[m[32m_last_owners = {1: None, 2: None, 3: None, 4: None, 5: None}[m
[32m+[m
[32m+[m[32m@tasks.loop(seconds=int(os.getenv("CRCON_POLL_SEC","2")))[m
[32m+[m[32masync def poll_crcon_sectors():[m
[32m+[m[32m    base = os.getenv("CRCON_HOST")[m
[32m+[m[32m    token = os.getenv("CRCON_TOKEN")[m
[32m+[m[32m    if not base or not token:[m
[32m+[m[32m        return  # disabled[m
[32m+[m[32m    try:[m
[32m+[m[32m        async with aiohttp.ClientSession() as sess:[m
[32m+[m[32m            # Replace this endpoint with your CRCON‚Äôs sector API[m
[32m+[m[32m            # Expecting a JSON like: {"sectors": [{"id":1,"owner":"ALLIES"}, ...]}[m
[32m+[m[32m            url = f"{base}/api/sectors"[m
[32m+[m[32m            headers = {"Authorization": f"Bearer {token}"}[m
[32m+[m[32m            async with sess.get(url, headers=headers, timeout=5) as r:[m
[32m+[m[32m                data = await r.json()[m
[32m+[m
[32m+[m[32m        # Parse & update owners[m
[32m+[m[32m        for s in data.get("sectors", []):[m
[32m+[m[32m            sid = int(s["id"])[m
[32m+[m[32m            owner = s.get("owner")[m
[32m+[m[32m            owner = owner if owner in ("ALLIES", "AXIS") else None[m
[32m+[m[32m            if sid in _last_owners and _last_owners[sid] != owner:[m
[32m+[m[32m                engine.set_sector_owner(sid, owner)[m
[32m+[m[32m                _last_owners[sid] = owner[m
[32m+[m
[32m+[m[32m    except Exception as e:[m
[32m+[m[32m        print("[TankScore] CRCON poll error:", e)[m
 [m
 def start_webhook_if_enabled():[m
     host = os.getenv("HLU_WEBHOOK_BIND", "")[m
[36m@@ -1384,7 +1418,59 @@[m [masync def on_app_command_error(interaction: discord.Interaction, error: discord.[m
 [m
 # Create the shared scoring engine and expose it to the webhook server[m
 engine = ScoreEngine()[m
[31m-WEBHOOK_ENGINE = engine  # makes the engine available inside the FastAPI app[m
[32m+[m[32mwebhook_server.ENGINE = engine  # sets the module's global used by FastAPI[m
[32m+[m[32mprint("[TankScore] ENGINE wired?",[m
[32m+[m[32m      "OK" if webhook_server.ENGINE is engine else "NOT SET")[m
[32m+[m
[32m+[m[32m# Wire engine change notifications to refresh the scoreboard safely from any thread[m
[32m+[m[32mdef _engine_listener(reason: str):[m
[32m+[m[32m    try:[m
[32m+[m[32m        if hasattr(bot, 'loop') and bot.loop:[m
[32m+[m[32m            bot.loop.call_soon_threadsafe(lambda: asyncio.create_task(update_all_tankscore_scoreboards()))[m
[32m+[m[32m    except Exception:[m
[32m+[m[32m        pass[m
[32m+[m
[32m+[m[32mtry:[m
[32m+[m[32m    engine.add_listener(_engine_listener)[m
[32m+[m[32mexcept Exception:[m
[32m+[m[32m    pass[m
[32m+[m
[32m+[m[32mdef _fmt_kbc(kbc):[m
[32m+[m[32m    # kbc: Dict[Team, Dict[VehicleClass, int]] -> concise string[m
[32m+[m[32m    def one(team):[m
[32m+[m[32m        if not kbc.get(team):[m
[32m+[m[32m            return "-"[m
[32m+[m[32m        return ", ".join(f"{cls}:{cnt}" for cls, cnt in kbc[team].items())[m
[32m+[m[32m    return one[m
[32m+[m
[32m+[m[32mdef build_tankscore_embed():[m
[32m+[m[32m    phase1, phase2, kbc = engine.totals()[m
[32m+[m[32m    holder = engine.holding_mid_team or "-"[m
[32m+[m[32m    embed = discord.Embed(title="TankScore Scoreboard", color=0x2b2d31)[m
[32m+[m[32m    embed.add_field(name="Mid Holder (Sector 3)", value=str(holder), inline=False)[m
[32m+[m[32m    embed.add_field(name="Hold Points (mid + >=4)", value=f"ALLIES: {phase1['ALLIES']} | AXIS: {phase1['AXIS']}", inline=False)[m
[32m+[m[32m    embed.add_field(name="Tank Kill Points", value=f"ALLIES: {phase2['ALLIES']} | AXIS: {phase2['AXIS']}", inline=False)[m
[32m+[m[32m    total_allies = round(phase1['ALLIES'],2) + phase2['ALLIES'][m
[32m+[m[32m    total_axis = round(phase1['AXIS'],2) + phase2['AXIS'][m
[32m+[m[32m    embed.add_field(name="Total Points", value=f"ALLIES: {round(total_allies,2)} | AXIS: {round(total_axis,2)}", inline=False)[m
[32m+[m[32m    fmt = _fmt_kbc(kbc)[m
[32m+[m[32m    embed.add_field(name="Kills by Class (ALLIES)", value=fmt('ALLIES'), inline=False)[m
[32m+[m[32m    embed.add_field(name="Kills by Class (AXIS)", value=fmt('AXIS'), inline=False)[m
[32m+[m[32m    embed.set_footer(text="Updates: every 10m, on mid change, or tank kill")[m
[32m+[m[32m    return embed[m
[32m+[m
[32m+[m[32masync def update_all_tankscore_scoreboards():[m
[32m+[m[32m    if not TANKSCORE_SCOREBOARDS:[m
[32m+[m[32m        return[m
[32m+[m[32m    embed = build_tankscore_embed()[m
[32m+[m[32m    # copy to avoid mutation during iteration[m
[32m+[m[32m    items = list(TANKSCORE_SCOREBOARDS.items())[m
[32m+[m[32m    for channel_id, message in items:[m
[32m+[m[32m        try:[m
[32m+[m[32m            await message.edit(embed=embed)[m
[32m+[m[32m        except Exception:[m
[32m+[m[32m            # if message no longer exists, drop it[m
[32m+[m[32m            TANKSCORE_SCOREBOARDS.pop(channel_id, None)[m
 [m
 # --- TankScore Slash Commands ---[m
 @bot.tree.command(name="tankscore_status", description="Show live tank scoring totals")[m
[36m@@ -1402,6 +1488,22 @@[m [masync def tankscore_status(interaction: discord.Interaction):[m
     )[m
     await interaction.response.send_message(msg, ephemeral=True)[m
 [m
[32m+[m[32m@bot.tree.command(name="tankscore_scoreboard", description="Post and auto-refresh the TankScore scoreboard here or in a channel")[m
[32m+[m[32masync def tankscore_scoreboard(interaction: discord.Interaction, channel: discord.TextChannel | None = None):[m
[32m+[m[32m    try:[m
[32m+[m[32m        await interaction.response.defer(ephemeral=True)[m
[32m+[m[32m        target = channel or interaction.channel[m
[32m+[m[32m        embed = build_tankscore_embed()[m
[32m+[m[32m        msg = await target.send(embed=embed)[m
[32m+[m[32m        TANKSCORE_SCOREBOARDS[target.id] = msg[m
[32m+[m[32m        await interaction.edit_original_response(content=f"TankScore scoreboard started in #{target.name}.")[m
[32m+[m[32m    except Exception as e:[m
[32m+[m[32m        await interaction.edit_original_response(content=f"Failed to start scoreboard: {e}")[m
[32m+[m
[32m+[m[32m@tasks.loop(minutes=10)[m
[32m+[m[32masync def refresh_tankscore_scoreboards():[m
[32m+[m[32m    await update_all_tankscore_scoreboards()[m
[32m+[m
 @bot.tree.command(name="tankscore_end", description="Compute end-of-match awards and show totals")[m
 async def tankscore_end(interaction: discord.Interaction):[m
     awards, details = engine.compute_awards()[m
[36m@@ -1436,6 +1538,11 @@[m [masync def on_ready():[m
     except Exception as e:[m
         logger.warning(f"‚ö†Ô∏è CRCON connection test failed: {e}")[m
     [m
[32m+[m[32m    # Register TankScore admin commands, then sync[m
[32m+[m[32m    try:[m
[32m+[m[32m        register_slash_commands(bot, engine)[m
[32m+[m[32m    except Exception as e:[m
[32m+[m[32m        logger.warning(f"Could not register TankScore admin commands: {e}")[m
     # Sync commands[m
     await bot.wait_until_ready()[m
     try:[m
[36m@@ -1449,7 +1556,9 @@[m [masync def on_ready():[m
     [m
     print(f"Logged in as {bot.user}")[m
     start_webhook_if_enabled()[m
[31m-    tick_scores.start()     # (we‚Äôll add this task below)[m
[32m+[m[32m    tick_scores.start()     # (we'll add this task below)[m
[32m+[m[32m    refresh_tankscore_scoreboards.start()[m
[32m+[m[32m    poll_crcon_sectors.start()[m
     # If you use app commands (slash), ensure the tree syncs:[m
     try:[m
         await bot.tree.sync()[m
[1mdiff --git a/tank_kills.jsonl b/tank_kills.jsonl[m
[1mnew file mode 100644[m
[1mindex 0000000..cb2d6e0[m
[1m--- /dev/null[m
[1m+++ b/tank_kills.jsonl[m
[36m@@ -0,0 +1 @@[m
[32m+[m[32m{"ts": "2025-09-15T01:26:10.440005+00:00", "killer_team": "ALLIES", "killer_squad": "A1", "victim_team": "AXIS", "victim_class": "HEAVY", "victim_name": "Tiger I", "map": "Remagen", "match_id": "test-1"}[m
[1mdiff --git a/tankscore/discord_ui.py b/tankscore/discord_ui.py[m
[1mnew file mode 100644[m
[1mindex 0000000..5515a50[m
[1m--- /dev/null[m
[1m+++ b/tankscore/discord_ui.py[m
[36m@@ -0,0 +1,23 @@[m
[32m+[m[32mfrom __future__ import annotations[m
[32m+[m[32mfrom discord import app_commands[m
[32m+[m[32mimport discord[m
[32m+[m
[32m+[m[32mdef is_admin():[m
[32m+[m[32m    # Simple check; customize to your needs (role ID, user ID, etc.)[m
[32m+[m[32m    def predicate(interaction: discord.Interaction) -> bool:[m
[32m+[m[32m        return interaction.user.guild_permissions.manage_guild[m
[32m+[m[32m    return app_commands.check(predicate)[m
[32m+[m
[32m+[m[32mdef register_slash_commands(bot, engine):[m
[32m+[m[32m    @bot.tree.command(name="tankscore_start", description="Start a new match (reset scores)")[m
[32m+[m[32m    @is_admin()[m
[32m+[m[32m    async def tankscore_start(interaction: discord.Interaction):[m
[32m+[m[32m        engine.reset()[m
[32m+[m[32m        await interaction.response.send_message("‚úÖ New match started. Scores reset.", ephemeral=True)[m
[32m+[m
[32m+[m[32m    @bot.tree.command(name="tankscore_reset", description="Reset scores (admin)")[m
[32m+[m[32m    @is_admin()[m
[32m+[m[32m    async def tankscore_reset(interaction: discord.Interaction):[m
[32m+[m[32m        engine.reset()[m
[32m+[m[32m        await interaction.response.send_message("‚ôªÔ∏è Scores reset.", ephemeral=True)[m
[32m+[m
[1mdiff --git a/tankscore/score_engine.py b/tankscore/score_engine.py[m
[1mindex 1ea23e4..ad2e51d 100644[m
[1m--- a/tankscore/score_engine.py[m
[1m+++ b/tankscore/score_engine.py[m
[36m@@ -37,11 +37,30 @@[m [mclass ScoreEngine:[m
         # squad streaks: key = (team, squad_id)[m
         self.squads = {}[m
         self._lock = threading.RLock()[m
[32m+[m[32m        # optional observers; callables that accept a string reason[m
[32m+[m[32m        self._listeners = []  # type: ignore[var-annotated][m
[32m+[m
[32m+[m[32m    def add_listener(self, func):[m
[32m+[m[32m        """Register a callback invoked on important scoring changes.[m
[32m+[m[32m        func(reason: str) will be called from the originating thread.[m
[32m+[m[32m        Reasons: 'mid_change', 'tank_kill'[m
[32m+[m[32m        """[m
[32m+[m[32m        with self._lock:[m
[32m+[m[32m            self._listeners.append(func)[m
[32m+[m
[32m+[m[32m    def _notify(self, reason: str):[m
[32m+[m[32m        # fire-and-forget; never raise out[m
[32m+[m[32m        for fn in list(self._listeners):[m
[32m+[m[32m            try:[m
[32m+[m[32m                fn(reason)[m
[32m+[m[32m            except Exception:[m
[32m+[m[32m                pass[m
 [m
     # ---------- Phase 1 ----------[m
     def set_sector_owner(self, sector_id: int, new_team: Optional[Team]):[m
         """Call this from your capture/ownership change handler."""[m
         with self._lock:[m
[32m+[m[32m            prev_mid = self.holding_mid_team[m
             self.control["ALLIES"].discard(sector_id)[m
             self.control["AXIS"].discard(sector_id)[m
             if new_team:[m
[36m@@ -52,6 +71,9 @@[m [mclass ScoreEngine:[m
                 self.holding_mid_team = "ALLIES"[m
             elif 3 in self.control["AXIS"]:[m
                 self.holding_mid_team = "AXIS"[m
[32m+[m[32m        # notify outside lock[m
[32m+[m[32m        if self.holding_mid_team != prev_mid:[m
[32m+[m[32m            self._notify('mid_change')[m
 [m
     def tick(self):[m
         """Accrue per-second points for mid & '4th point held'."""[m
[36m@@ -74,6 +96,7 @@[m [mclass ScoreEngine:[m
         with self._lock:[m
             self.score_tanks[killer_team] += self.tank_kill_pts[m
             self.kills_by_class[killer_team][victim_class] += 1[m
[32m+[m[32m        self._notify('tank_kill')[m
 [m
     # ---------- Phase 3 (squad streaks & awards) ----------[m
     def _squad_key(self, team: Team, squad_id: str):[m
[36m@@ -102,6 +125,16 @@[m [mclass ScoreEngine:[m
             S = self._ensure_squad(team, squad_id)[m
             S["current_streak"] = 0[m
 [m
[32m+[m[32m    def reset(self):[m
[32m+[m[32m        with self._lock:[m
[32m+[m[32m            self.control = {"ALLIES": set(), "AXIS": set()}[m
[32m+[m[32m            self.holding_mid_team = None[m
[32m+[m[32m            self.last_tick = time.monotonic()[m
[32m+[m[32m            self.score_mid_fourth = {"ALLIES": 0.0, "AXIS": 0.0}[m
[32m+[m[32m            self.score_tanks = {"ALLIES": 0, "AXIS": 0}[m
[32m+[m[32m            self.kills_by_class = {"ALLIES": defaultdict(int), "AXIS": defaultdict(int)}[m
[32m+[m[32m            self.squads = {}[m
[32m+[m
     def compute_awards(self):[m
         """Return (award_points_by_team, details) at match end."""[m
         with self._lock:[m
[1mdiff --git a/tankscore/store.py b/tankscore/store.py[m
[1mnew file mode 100644[m
[1mindex 0000000..335b9e6[m
[1m--- /dev/null[m
[1m+++ b/tankscore/store.py[m
[36m@@ -0,0 +1,15 @@[m
[32m+[m[32mfrom __future__ import annotations[m
[32m+[m[32mimport json, os, datetime[m
[32m+[m[32mfrom typing import Any, Dict[m
[32m+[m
[32m+[m[32mdef now_ts() -> str:[m
[32m+[m[32m    return datetime.datetime.utcnow().replace(tzinfo=datetime.timezone.utc).isoformat()[m
[32m+[m
[32m+[m[32mdef append_jsonl(path: str, obj: Dict[str, Any]) -> None:[m
[32m+[m[32m    # ensure dir exists[m
[32m+[m[32m    d = os.path.dirname(path)[m
[32m+[m[32m    if d and not os.path.exists(d):[m
[32m+[m[32m        os.makedirs(d, exist_ok=True)[m
[32m+[m[32m    with open(path, 'a', encoding='utf-8') as f:[m
[32m+[m[32m        f.write(json.dumps(obj, ensure_ascii=False) + "\n")[m
[32m+[m
[1mdiff --git a/tankscore/vehicle_map.py b/tankscore/vehicle_map.py[m
[1mnew file mode 100644[m
[1mindex 0000000..abc1d82[m
[1m--- /dev/null[m
[1m+++ b/tankscore/vehicle_map.py[m
[36m@@ -0,0 +1,39 @@[m
[32m+[m[32mfrom __future__ import annotations[m
[32m+[m
[32m+[m[32m# Very lightweight name -> class classifier[m
[32m+[m[32m# Returns one of: 'LIGHT','MEDIUM','HEAVY','TD' or None if unknown/non-tank[m
[32m+[m
[32m+[m[32mdef classify_by_name(name: str) -> str | None:[m
[32m+[m[32m    if not name:[m
[32m+[m[32m        return None[m
[32m+[m[32m    n = name.strip().lower()[m
[32m+[m
[32m+[m[32m    # common HLL vehicle name hints[m
[32m+[m[32m    heavy_tokens = [[m
[32m+[m[32m        "tiger", "king tiger", "t-34-85", "is-2", "is2", "pershing",[m
[32m+[m[32m        "panther", "jumbo 76", "sherman 76"[m
[32m+[m[32m    ][m
[32m+[m[32m    medium_tokens = [[m
[32m+[m[32m        "sherman", "jumbo", "pz iv", "pzkpfw iv", "t-34", "t34", "comet",[m
[32m+[m[32m        "cromwell"[m
[32m+[m[32m    ][m
[32m+[m[32m    light_tokens = [[m
[32m+[m[32m        "stewart", "stuart", "luchs", "m8", "greyhound", "grey hound", "t70",[m
[32m+[m[32m    ][m
[32m+[m[32m    td_tokens = [[m
[32m+[m[32m        "stuG", "stug", "su-76", "m10", "achilles", "jpz", "jagdpanzer",[m
[32m+[m[32m    ][m
[32m+[m
[32m+[m[32m    def has_any(tokens):[m
[32m+[m[32m        return any(tok in n for tok in tokens)[m
[32m+[m
[32m+[m[32m    if has_any(heavy_tokens):[m
[32m+[m[32m        return "HEAVY"[m
[32m+[m[32m    if has_any(medium_tokens):[m
[32m+[m[32m        return "MEDIUM"[m
[32m+[m[32m    if has_any(light_tokens):[m
[32m+[m[32m        return "LIGHT"[m
[32m+[m[32m    if has_any(td_tokens):[m
[32m+[m[32m        return "TD"[m
[32m+[m[32m    return None[m
[32m+[m
[1mdiff --git a/tankscore/webhook_server.py b/tankscore/webhook_server.py[m
[1mindex 9e403d3..34da470 100644[m
[1m--- a/tankscore/webhook_server.py[m
[1m+++ b/tankscore/webhook_server.py[m
[36m@@ -2,12 +2,21 @@[m [mfrom __future__ import annotations[m
 import hmac, hashlib, os, typing as T[m
 from fastapi import FastAPI, Request, HTTPException[m
 from pydantic import BaseModel, Field[m
[31m-from .score_engine import ScoreEngine, Team, VehicleClass[m
[32m+[m[32mfrom .score_engine import ScoreEngine, Team[m
[32m+[m[32mfrom .vehicle_map import classify_by_name[m
[32m+[m[32mfrom .store import append_jsonl, now_ts[m
 [m
 app = FastAPI()[m
[31m-ENGINE: ScoreEngine | None = None  # set by caller[m
[32m+[m[32mENGINE: ScoreEngine | None = None[m
 SECRET = os.getenv("HLU_WEBHOOK_SHARED_SECRET","").encode()[m
 [m
[32m+[m[32m# Pydantic v1/v2 helper[m
[32m+[m[32mdef _validate(model_cls, data: dict):[m
[32m+[m[32m    if hasattr(model_cls, "model_validate"):[m
[32m+[m[32m        return model_cls.model_validate(data)   # v2[m
[32m+[m[32m    return model_cls.parse_obj(data)            # v1[m
[32m+[m
[32m+[m[32m# --- Models ---[m
 class Killer(BaseModel):[m
     name: str[m
     steam_id: str[m
[36m@@ -16,7 +25,8 @@[m [mclass Killer(BaseModel):[m
 [m
 class VictimVehicle(BaseModel):[m
     side: Team[m
[31m-    class_: VehicleClass = Field(alias="class")[m
[32m+[m[32m    # make class optional and accept any string; we'll normalize later[m
[32m+[m[32m    class_: str | None = Field(default=None, alias="class")[m
     name: str[m
 [m
 class VehicleDestroyed(BaseModel):[m
[36m@@ -47,21 +57,44 @@[m [masync def event(request: Request):[m
     raw = await request.body()[m
     _verify(raw, request.headers.get("X-HLU-Signature"))[m
     data = await request.json()[m
[31m-    global ENGINE[m
     if ENGINE is None:[m
         raise HTTPException(503, "engine not ready")[m
 [m
     t = data.get("type")[m
     if t == "vehicle_destroyed":[m
[31m-        evt = VehicleDestroyed.model_validate(data)[m
[31m-        ENGINE.on_tank_kill(evt.killer.team, evt.victim_vehicle.class_)[m
[32m+[m[32m        evt = _validate(VehicleDestroyed, data)[m
[32m+[m[32m        # --- fallback classification by name if class is missing/None ---[m
[32m+[m[32m        raw_cls = evt.victim_vehicle.class_[m
[32m+[m[32m        mapped_cls = classify_by_name(evt.victim_vehicle.name) if raw_cls is None else None[m
[32m+[m[32m        victim_cls = (raw_cls or mapped_cls or "MEDIUM").upper()[m
[32m+[m[32m        # Log when we truly couldn't classify by provided class or name[m
[32m+[m[32m        if raw_cls is None and mapped_cls is None:[m
[32m+[m[32m            print(f"[TankScore] Add to vehicles.yml: '{evt.victim_vehicle.name}': <LIGHT|MEDIUM|HEAVY|TD>")[m
[32m+[m[32m        if victim_cls not in {"LIGHT","MEDIUM","HEAVY","TD"}:[m
[32m+[m[32m            print(f"[TankScore] Unknown vehicle class '{victim_cls}' for name '{evt.victim_vehicle.name}'")[m
[32m+[m[32m            # ignore non-tank classes safely[m
[32m+[m[32m            return {"ignored": f"non-tank class: {victim_cls}"}[m
[32m+[m[32m        # scoring & streak[m
[32m+[m[32m        ENGINE.on_tank_kill(evt.killer.team, victim_cls)  # type: ignore[arg-type][m
         if evt.killer.squad_id:[m
             ENGINE.on_squad_tank_kill(evt.killer.team, evt.killer.squad_id)[m
[32m+[m[32m        # persist[m
[32m+[m[32m        append_jsonl("tank_kills.jsonl", {[m
[32m+[m[32m            "ts": now_ts(),[m
[32m+[m[32m            "killer_team": evt.killer.team,[m
[32m+[m[32m            "killer_squad": evt.killer.squad_id,[m
[32m+[m[32m            "victim_team": evt.victim_vehicle.side,[m
[32m+[m[32m            "victim_class": victim_cls,[m
[32m+[m[32m            "victim_name": evt.victim_vehicle.name,[m
[32m+[m[32m            "map": evt.map,[m
[32m+[m[32m            "match_id": evt.match_id,[m
[32m+[m[32m        })[m
         return {"ok": True}[m
[31m-    elif t == "player_death":[m
[31m-        evt = PlayerDeath.model_validate(data)[m
[32m+[m
[32m+[m[32m    if t == "player_death":[m
[32m+[m[32m        evt = _validate(PlayerDeath, data)[m
         if evt.squad_id:[m
             ENGINE.on_squad_member_death(evt.team, evt.squad_id)[m
         return {"ok": True}[m
[31m-    else:[m
[31m-        return {"ignored": t}[m
[32m+[m
[32m+[m[32m    return {"ignored": t}[m
[1mdiff --git a/tankscore_m4-6.patch b/tankscore_m4-6.patch[m
[1mnew file mode 100644[m
[1mindex 0000000..32a622b[m
[1m--- /dev/null[m
[1m+++ b/tankscore_m4-6.patch[m
[36m@@ -0,0 +1,406 @@[m
[32m+[m[32m*** a/requirements.txt[m
[32m+[m[32m--- b/requirements.txt[m
[32m+[m[32m@@[m
[32m+[m[32m discord.py>=2.3.2[m
[32m+[m[32m python-dotenv>=1.0.1[m
[32m+[m[32m fastapi>=0.115.0[m
[32m+[m[32m uvicorn[standard]>=0.30.0[m
[32m+[m[32m pydantic>=2.8.2[m
[32m+[m[32m+PyYAML>=6.0.1[m
[32m+[m
[32m+[m[32m*** /dev/null[m
[32m+[m[32m--- b/tankscore/vehicles.yml[m
[32m+[m[32m@@[m
[32m+[m[32m+# Axis[m
[32m+[m[32m+"Tiger I": HEAVY[m
[32m+[m[32m+"Panther": MEDIUM[m
[32m+[m[32m+"Panzer IV": MEDIUM[m
[32m+[m[32m+"StuG III": TD[m
[32m+[m[32m+[m
[32m+[m[32m+# Allies[m
[32m+[m[32m+"Sherman 75": MEDIUM[m
[32m+[m[32m+"Sherman 76": MEDIUM[m
[32m+[m[32m+"Jumbo 75": HEAVY[m
[32m+[m[32m+"Jumbo 76": HEAVY[m
[32m+[m[32m+"Greyhound": LIGHT[m
[32m+[m[32m+"Stuart": LIGHT[m
[32m+[m
[32m+[m[32m*** /dev/null[m
[32m+[m[32m--- b/tankscore/vehicle_map.py[m
[32m+[m[32m@@[m
[32m+[m[32m+from __future__ import annotations[m
[32m+[m[32m+import os[m
[32m+[m[32m+from typing import Optional, Dict[m
[32m+[m[32m+import yaml[m
[32m+[m[32m+[m
[32m+[m[32m+_MAP: Optional[Dict[str, str]] = None[m
[32m+[m[32m+[m
[32m+[m[32m+def load_vehicle_map() -> Dict[str, str]:[m
[32m+[m[32m+    global _MAP[m
[32m+[m[32m+    if _MAP is not None:[m
[32m+[m[32m+        return _MAP[m
[32m+[m[32m+    path_candidates = [[m
[32m+[m[32m+        os.path.join(os.getcwd(), "tankscore", "vehicles.yml"),[m
[32m+[m[32m+        os.path.join(os.path.dirname(__file__), "vehicles.yml"),[m
[32m+[m[32m+    ][m
[32m+[m[32m+    data: Dict[str, str] = {}[m
[32m+[m[32m+    for p in path_candidates:[m
[32m+[m[32m+        if os.path.exists(p):[m
[32m+[m[32m+            with open(p, "r", encoding="utf-8") as f:[m
[32m+[m[32m+                loaded = yaml.safe_load(f) or {}[m
[32m+[m[32m+                if isinstance(loaded, dict):[m
[32m+[m[32m+                    data.update({str(k): str(v) for k, v in loaded.items()})[m
[32m+[m[32m+            break[m
[32m+[m[32m+    _MAP = data[m
[32m+[m[32m+    return _MAP[m
[32m+[m[32m+[m
[32m+[m[32m+def classify_by_name(name: str) -> Optional[str]:[m
[32m+[m[32m+    return load_vehicle_map().get(name)[m
[32m+[m
[32m+[m[32m*** /dev/null[m
[32m+[m[32m--- b/tankscore/store.py[m
[32m+[m[32m@@[m
[32m+[m[32m+from __future__ import annotations[m
[32m+[m[32m+import json, os, time[m
[32m+[m[32m+from typing import Any, Dict[m
[32m+[m[32m+[m
[32m+[m[32m+DATA_DIR = os.environ.get("TANKSCORE_DATA_DIR", "data")[m
[32m+[m[32m+os.makedirs(DATA_DIR, exist_ok=True)[m
[32m+[m[32m+[m
[32m+[m[32m+def now_ts() -> str:[m
[32m+[m[32m+    return time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime())[m
[32m+[m[32m+[m
[32m+[m[32m+def append_jsonl(filename: str, obj: Dict[str, Any]) -> None:[m
[32m+[m[32m+    path = os.path.join(DATA_DIR, filename)[m
[32m+[m[32m+    with open(path, "a", encoding="utf-8") as f:[m
[32m+[m[32m+        f.write(json.dumps(obj, ensure_ascii=False) + "\n")[m
[32m+[m
[32m+[m[32m*** /dev/null[m
[32m+[m[32m--- b/tankscore/export_csv.py[m
[32m+[m[32m@@[m
[32m+[m[32m+from __future__ import annotations[m
[32m+[m[32m+import csv, os[m
[32m+[m[32m+from typing import List, Dict, Any[m
[32m+[m[32m+[m
[32m+[m[32m+DATA_DIR = os.environ.get("TANKSCORE_DATA_DIR", "data")[m
[32m+[m[32m+os.makedirs(DATA_DIR, exist_ok=True)[m
[32m+[m[32m+[m
[32m+[m[32m+def write_scoreboard_csv(match_id: str, rows: List[Dict[str, Any]]) -> str:[m
[32m+[m[32m+    path = os.path.join(DATA_DIR, f"scoreboard_{match_id}.csv")[m
[32m+[m[32m+    fields = sorted(rows[0].keys()) if rows else ["team","phase1","phase2","awards","total"][m
[32m+[m[32m+    with open(path, "w", newline="", encoding="utf-8") as f:[m
[32m+[m[32m+        w = csv.DictWriter(f, fieldnames=fields)[m
[32m+[m[32m+        w.writeheader()[m
[32m+[m[32m+        for r in rows:[m
[32m+[m[32m+            w.writerow(r)[m
[32m+[m[32m+    return path[m
[32m+[m
[32m+[m[32m*** /dev/null[m
[32m+[m[32m--- b/tankscore/discord_ui.py[m
[32m+[m[32m@@[m
[32m+[m[32m+from __future__ import annotations[m
[32m+[m[32m+import time[m
[32m+[m[32m+import discord[m
[32m+[m[32m+from discord import app_commands[m
[32m+[m[32m+from typing import Dict[m
[32m+[m[32m+[m
[32m+[m[32m+def format_kills_by_class(kbc_team: Dict[str,int]) -> str:[m
[32m+[m[32m+    order = ["LIGHT","MEDIUM","HEAVY","TD"][m
[32m+[m[32m+    return " ".join(f"{k[0]}:{int(kbc_team.get(k,0))}" for k in order)[m
[32m+[m[32m+[m
[32m+[m[32m+def register_slash_commands(bot, engine):[m
[32m+[m[32m+    @bot.tree.command(name="tankscore_status", description="Show current tank scoring totals")[m
[32m+[m[32m+    async def tankscore_status(interaction: discord.Interaction):[m
[32m+[m[32m+        phase1, phase2, kbc = engine.totals()[m
[32m+[m[32m+        embed = discord.Embed([m
[32m+[m[32m+            title="üîß Tank Score ‚Äî Live",[m
[32m+[m[32m+            description="Phase 1: Mid & ‚â•4 sectors per-minute accrual\nPhase 2: Tank kills",[m
[32m+[m[32m+            color=0x2b6cb0[m
[32m+[m[32m+        )[m
[32m+[m[32m+        embed.add_field(name="Phase 1 ‚Äî Mid+4th",[m
[32m+[m[32m+                        value=f"**ALLIES:** {phase1['ALLIES']:.2f}\n**AXIS:** {phase1['AXIS']:.2f}",[m
[32m+[m[32m+                        inline=True)[m
[32m+[m[32m+        embed.add_field(name="Phase 2 ‚Äî Tank points",[m
[32m+[m[32m+                        value=f"**ALLIES:** {phase2['ALLIES']}\n**AXIS:** {phase2['AXIS']}",[m
[32m+[m[32m+                        inline=True)[m
[32m+[m[32m+        embed.add_field(name="Per-class (L/M/H/TD)",[m
[32m+[m[32m+                        value=(f"**ALLIES:** {format_kills_by_class(kbc['ALLIES'])}\n"[m
[32m+[m[32m+                               f"**AXIS:** {format_kills_by_class(kbc['AXIS'])}"),[m
[32m+[m[32m+                        inline=False)[m
[32m+[m[32m+        await interaction.response.send_message(embed=embed, ephemeral=True)[m
[32m+[m[32m+[m
[32m+[m[32m+    @bot.tree.command(name="tankscore_end", description="End match, compute awards, show final totals, and export CSV")[m
[32m+[m[32m+    async def tankscore_end(interaction: discord.Interaction):[m
[32m+[m[32m+        await interaction.response.defer()[m
[32m+[m[32m+        awards, details = engine.compute_awards()[m
[32m+[m[32m+        phase1, phase2, _ = engine.totals()[m
[32m+[m[32m+        total = {[m
[32m+[m[32m+            "ALLIES": round(phase1["ALLIES"], 2) + phase2["ALLIES"] + awards["ALLIES"],[m
[32m+[m[32m+            "AXIS":   round(phase1["AXIS"], 2)   + phase2["AXIS"]   + awards["AXIS"],[m
[32m+[m[32m+        }[m
[32m+[m[32m+        def fmt_list(xs):[m
[32m+[m[32m+            return ", ".join([f"{t}/{s}" for (t, s) in xs]) if xs else "(none)"[m
[32m+[m[32m+        ironhide = (f"{details['ironhide'][0]}/{details['ironhide'][1]}"[m
[32m+[m[32m+                    if details["ironhide"] else "(none)")[m
[32m+[m[32m+        winner = "Tie"[m
[32m+[m[32m+        if total["ALLIES"] > total["AXIS"]:[m
[32m+[m[32m+            winner = "ALLIES"[m
[32m+[m[32m+        elif total["AXIS"] > total["ALLIES"]:[m
[32m+[m[32m+            winner = "AXIS"[m
[32m+[m[32m+        embed = discord.Embed([m
[32m+[m[32m+            title="üèÅ Tank Score ‚Äî Final",[m
[32m+[m[32m+            description=f"Winner: **{winner}**",[m
[32m+[m[32m+            color=0x38a169[m
[32m+[m[32m+        )[m
[32m+[m[32m+        embed.add_field(name="Phase 1 ‚Äî Mid+4th",[m
[32m+[m[32m+                        value=f"ALLIES: {phase1['ALLIES']:.2f}\nAXIS: {phase1['AXIS']:.2f}",[m
[32m+[m[32m+                        inline=True)[m
[32m+[m[32m+        embed.add_field(name="Phase 2 ‚Äî Tank points",[m
[32m+[m[32m+                        value=f"ALLIES: {phase2['ALLIES']}\nAXIS: {phase2['AXIS']}",[m
[32m+[m[32m+                        inline=True)[m
[32m+[m[32m+        embed.add_field(name=f"Awards (Vet +{engine.vet_pts}, Ace +{engine.ace_pts}, IRONHIDE +{engine.ironhide_pts})",[m
[32m+[m[32m+                        value=(f"Veteran: {fmt_list(details['veteran'])}\n"[m
[32m+[m[32m+                               f"Ace: {fmt_list(details['ace'])}\n"[m
[32m+[m[32m+                               f"IRONHIDE: {ironhide}"),[m
[32m+[m[32m+                        inline=False)[m
[32m+[m[32m+        embed.add_field(name="Totals",[m
[32m+[m[32m+                        value=(f"ALLIES: {round(phase1['ALLIES'],2)} + {phase2['ALLIES']} + {awards['ALLIES']} "[m
[32m+[m[32m+                               f"= **{total['ALLIES']}**\n"[m
[32m+[m[32m+                               f"AXIS:   {round(phase1['AXIS'],2)} + {phase2['AXIS']} + {awards['AXIS']} "[m
[32m+[m[32m+                               f"= **{total['AXIS']}**"),[m
[32m+[m[32m+                        inline=False)[m
[32m+[m[32m+        await interaction.followup.send(embed=embed)[m
[32m+[m[32m+[m
[32m+[m[32m+        # CSV export[m
[32m+[m[32m+        import time as _time[m
[32m+[m[32m+        from .export_csv import write_scoreboard_csv[m
[32m+[m[32m+        match_id = _time.strftime("%Y%m%d-%H%M%S")[m
[32m+[m[32m+        rows = [[m
[32m+[m[32m+            {"team":"ALLIES","phase1":round(phase1["ALLIES"],2),"phase2":phase2["ALLIES"],[m
[32m+[m[32m+             "awards":awards["ALLIES"],"total":total["ALLIES"]},[m
[32m+[m[32m+            {"team":"AXIS","phase1":round(phase1["AXIS"],2),"phase2":phase2["AXIS"],[m
[32m+[m[32m+             "awards":awards["AXIS"],"total":total["AXIS"]},[m
[32m+[m[32m+        ][m
[32m+[m[32m+        csv_path = write_scoreboard_csv(match_id, rows)[m
[32m+[m[32m+        await interaction.followup.send(file=discord.File(csv_path))[m
[32m+[m
[32m+[m[32m*** a/tankscore/webhook_server.py[m
[32m+[m[32m--- b/tankscore/webhook_server.py[m
[32m+[m[32m@@[m
[32m+[m[32m-from __future__ import annotations[m
[32m+[m[32m-import hmac, hashlib, os, typing as T[m
[32m+[m[32m-from fastapi import FastAPI, Request, HTTPException[m
[32m+[m[32m-from pydantic import BaseModel, Field[m
[32m+[m[32m-from .score_engine import ScoreEngine, Team, VehicleClass[m
[32m+[m[32m-[m
[32m+[m[32m-app = FastAPI()[m
[32m+[m[32m-ENGINE: ScoreEngine | None = None  # set by caller[m
[32m+[m[32m-SECRET = os.getenv("HLU_WEBHOOK_SHARED_SECRET","").encode()[m
[32m+[m[32m-[m
[32m+[m[32m-class Killer(BaseModel):[m
[32m+[m[32m-    name: str[m
[32m+[m[32m-    steam_id: str[m
[32m+[m[32m-    team: Team[m
[32m+[m[32m-    squad_id: str | None = None[m
[32m+[m[32m-[m
[32m+[m[32m-class VictimVehicle(BaseModel):[m
[32m+[m[32m-    side: Team[m
[32m+[m[32m-    class_: VehicleClass = Field(alias="class")[m
[32m+[m[32m-    name: str[m
[32m+[m[32m-[m
[32m+[m[32m-class VehicleDestroyed(BaseModel):[m
[32m+[m[32m-    type: T.Literal["vehicle_destroyed"][m
[32m+[m[32m-    timestamp: str[m
[32m+[m[32m-    killer: Killer[m
[32m+[m[32m-    victim_vehicle: VictimVehicle[m
[32m+[m[32m-    map: str | None = None[m
[32m+[m[32m-    match_id: str | None = None[m
[32m+[m[32m-[m
[32m+[m[32m-class PlayerDeath(BaseModel):[m
[32m+[m[32m-    type: T.Literal["player_death"][m
[32m+[m[32m-    timestamp: str[m
[32m+[m[32m-    team: Team[m
[32m+[m[32m-    squad_id: str | None = None[m
[32m+[m[32m-[m
[32m+[m[32m-def _verify(req_body: bytes, signature: str | None):[m
[32m+[m[32m-    if not SECRET:[m
[32m+[m[32m-        return[m
[32m+[m[32m-    if not signature:[m
[32m+[m[32m-        raise HTTPException(401, "missing signature")[m
[32m+[m[32m-    mac = hmac.new(SECRET, req_body, hashlib.sha256).hexdigest()[m
[32m+[m[32m-    if not hmac.compare_digest(mac, signature):[m
[32m+[m[32m-        raise HTTPException(401, "bad signature")[m
[32m+[m[32m-[m
[32m+[m[32m-@app.post("/event")[m
[32m+[m[32m-async def event(request: Request):[m
[32m+[m[32m-    raw = await request.body()[m
[32m+[m[32m-    _verify(raw, request.headers.get("X-HLU-Signature"))[m
[32m+[m[32m-    data = await request.json()[m
[32m+[m[32m-    global ENGINE[m
[32m+[m[32m-    if ENGINE is None:[m
[32m+[m[32m-        raise HTTPException(503, "engine not ready")[m
[32m+[m[32m-[m
[32m+[m[32m-    t = data.get("type")[m
[32m+[m[32m-    if t == "vehicle_destroyed":[m
[32m+[m[32m-        evt = VehicleDestroyed.model_validate(data)[m
[32m+[m[32m-        # Phase 2: killer's team gets tank points; track class[m
[32m+[m[32m-        ENGINE.on_tank_kill(evt.killer.team, evt.victim_vehicle.class_)[m
[32m+[m[32m-        # Phase 3: if killer is in an Armor squad (squad_id provided), increment streak[m
[32m+[m[32m-        if evt.killer.squad_id:[m
[32m+[m[32m-            ENGINE.on_squad_tank_kill(evt.killer.team, evt.killer.squad_id)[m
[32m+[m[32m-        return {"ok": True}[m
[32m+[m[32m-    elif t == "player_death":[m
[32m+[m[32m-        evt = PlayerDeath.model_validate(data)[m
[32m+[m[32m-        if evt.squad_id:[m
[32m+[m[32m-            ENGINE.on_squad_member_death(evt.team, evt.squad_id)[m
[32m+[m[32m-        return {"ok": True}[m
[32m+[m[32m-    else:[m
[32m+[m[32m-        return {"ignored": t}[m
[32m+[m[32m+from __future__ import annotations[m
[32m+[m[32m+import hmac, hashlib, os, typing as T[m
[32m+[m[32m+from fastapi import FastAPI, Request, HTTPException[m
[32m+[m[32m+from pydantic import BaseModel, Field[m
[32m+[m[32m+from .score_engine import ScoreEngine, Team, VehicleClass[m
[32m+[m[32m+from .vehicle_map import classify_by_name[m
[32m+[m[32m+from .store import append_jsonl, now_ts[m
[32m+[m[32m+[m
[32m+[m[32m+app = FastAPI()[m
[32m+[m[32m+ENGINE: ScoreEngine | None = None  # set by caller[m
[32m+[m[32m+SECRET = os.getenv("HLU_WEBHOOK_SHARED_SECRET","").encode()[m
[32m+[m[32m+[m
[32m+[m[32m+# ---- Pydantic v1/v2 compat ----[m
[32m+[m[32m+def _validate(model_cls, data: dict):[m
[32m+[m[32m+    if hasattr(model_cls, "model_validate"):[m
[32m+[m[32m+        return model_cls.model_validate(data)   # v2[m
[32m+[m[32m+    return model_cls.parse_obj(data)            # v1[m
[32m+[m[32m+[m
[32m+[m[32m+class Killer(BaseModel):[m
[32m+[m[32m+    name: str[m
[32m+[m[32m+    steam_id: str[m
[32m+[m[32m+    team: Team[m
[32m+[m[32m+    squad_id: str | None = None[m
[32m+[m[32m+[m
[32m+[m[32m+class VictimVehicle(BaseModel):[m
[32m+[m[32m+    side: Team[m
[32m+[m[32m+    class_: VehicleClass | None = Field(default=None, alias="class")[m
[32m+[m[32m+    name: str[m
[32m+[m[32m+[m
[32m+[m[32m+class VehicleDestroyed(BaseModel):[m
[32m+[m[32m+    type: T.Literal["vehicle_destroyed"][m
[32m+[m[32m+    timestamp: str[m
[32m+[m[32m+    killer: Killer[m
[32m+[m[32m+    victim_vehicle: VictimVehicle[m
[32m+[m[32m+    map: str | None = None[m
[32m+[m[32m+    match_id: str | None = None[m
[32m+[m[32m+[m
[32m+[m[32m+class PlayerDeath(BaseModel):[m
[32m+[m[32m+    type: T.Literal["player_death"][m
[32m+[m[32m+    timestamp: str[m
[32m+[m[32m+    team: Team[m
[32m+[m[32m+    squad_id: str | None = None[m
[32m+[m[32m+[m
[32m+[m[32m+def _verify(req_body: bytes, signature: str | None):[m
[32m+[m[32m+    if not SECRET:[m
[32m+[m[32m+        return[m
[32m+[m[32m+    if not signature:[m
[32m+[m[32m+        raise HTTPException(401, "missing signature")[m
[32m+[m[32m+    mac = hmac.new(SECRET, req_body, hashlib.sha256).hexdigest()[m
[32m+[m[32m+    if not hmac.compare_digest(mac, signature):[m
[32m+[m[32m+        raise HTTPException(401, "bad signature")[m
[32m+[m[32m+[m
[32m+[m[32m+@app.post("/event")[m
[32m+[m[32m+async def event(request: Request):[m
[32m+[m[32m+    raw = await request.body()[m
[32m+[m[32m+    _verify(raw, request.headers.get("X-HLU-Signature"))[m
[32m+[m[32m+    data = await request.json()[m
[32m+[m[32m+    if ENGINE is None:[m
[32m+[m[32m+        raise HTTPException(503, "engine not ready")[m
[32m+[m[32m+[m
[32m+[m[32m+    t = data.get("type")[m
[32m+[m[32m+    if t == "vehicle_destroyed":[m
[32m+[m[32m+        evt = _validate(VehicleDestroyed, data)[m
[32m+[m[32m+        # Class fallback via vehicle name if class missing/None[m
[32m+[m[32m+        victim_cls = evt.victim_vehicle.class_ or classify_by_name(evt.victim_vehicle.name) or "MEDIUM"[m
[32m+[m[32m+        # Phase 2 score + Phase 3 streak[m
[32m+[m[32m+        ENGINE.on_tank_kill(evt.killer.team, victim_cls)  # type: ignore[arg-type][m
[32m+[m[32m+        if evt.killer.squad_id:[m
[32m+[m[32m+            ENGINE.on_squad_tank_kill(evt.killer.team, evt.killer.squad_id)[m
[32m+[m[32m+        # Persist event[m
[32m+[m[32m+        append_jsonl("tank_kills.jsonl", {[m
[32m+[m[32m+            "ts": now_ts(),[m
[32m+[m[32m+            "killer_team": evt.killer.team,[m
[32m+[m[32m+            "killer_squad": evt.killer.squad_id,[m
[32m+[m[32m+            "victim_team": evt.victim_vehicle.side,[m
[32m+[m[32m+            "victim_class": victim_cls,[m
[32m+[m[32m+            "victim_name": evt.victim_vehicle.name,[m
[32m+[m[32m+            "map": evt.map,[m
[32m+[m[32m+            "match_id": evt.match_id,[m
[32m+[m[32m+        })[m
[32m+[m[32m+        return {"ok": True}[m
[32m+[m[32m+[m
[32m+[m[32m+    if t == "player_death":[m
[32m+[m[32m+        evt = _validate(PlayerDeath, data)[m
[32m+[m[32m+        if evt.squad_id:[m
[32m+[m[32m+            ENGINE.on_squad_member_death(evt.team, evt.squad_id)[m
[32m+[m[32m+        return {"ok": True}[m
[32m+[m[32m+[m
[32m+[m[32m+    return {"ignored": t}[m
[32m+[m
[32m+[m[32m*** a/enhanced_discord_bot.py[m
[32m+[m[32m--- b/enhanced_discord_bot.py[m
[32m+[m[32m@@[m
[32m+[m[32m import os[m
[32m+[m[32m@@[m
[32m+[m[32m from discord.ext import commands[m
[32m+[m[32m+from discord.ext import tasks[m
[32m+[m[32m@@[m
[32m+[m[32m from dotenv import load_dotenv[m
[32m+[m[32m@@[m
[32m+[m[32m-from tankscore.score_engine import ScoreEngine[m
[32m+[m[32m-from tankscore.webhook_server import app as webhook_app, ENGINE as WEBHOOK_ENGINE[m
[32m+[m[32m+# Tank scoring imports[m
[32m+[m[32m+from tankscore.score_engine import ScoreEngine[m
[32m+[m[32m+import tankscore.webhook_server as webhook_server[m
[32m+[m[32m+from tankscore.discord_ui import register_slash_commands[m
[32m+[m[32m+import uvicorn, threading[m
[32m+[m[32m@@[m
[32m+[m[32m load_dotenv()[m
[32m+[m[32m@@[m
[32m+[m[32m-bot = commands.Bot(command_prefix="!", intents=commands.Intents.default())[m
[32m+[m[32m-engine = ScoreEngine()[m
[32m+[m[32m-WEBHOOK_ENGINE = engine  # hand over to FastAPI[m
[32m+[m[32m+bot = commands.Bot(command_prefix="!", intents=commands.Intents.default())[m
[32m+[m[32m+engine = ScoreEngine()[m
[32m+[m[32m+webhook_app = webhook_server.app[m
[32m+[m[32m+webhook_server.ENGINE = engine  # hand the engine to FastAPI[m
[32m+[m[32m+register_slash_commands(bot, engine)[m
[32m+[m[32m@@[m
[32m+[m[32m @bot.event[m
[32m+[m[32m async def on_ready():[m
[32m+[m[32m     print(f"Logged in as {bot.user}")[m
[32m+[m[32m-    start_webhook_if_needed()[m
[32m+[m[32m-    tick_scores.start()[m
[32m+[m[32m+    start_webhook_if_needed()[m
[32m+[m[32m+    tick_scores.start()[m
[32m+[m[32m     try:[m
[32m+[m[32m         await bot.tree.sync()[m
[32m+[m[32m         print("Slash commands synced.")[m
[32m+[m[32m     except Exception as e:[m
[32m+[m[32m         print("Slash sync failed:", e)[m
[32m+[m[32m@@[m
[32m+[m[32m+def start_webhook_if_needed():[m
[32m+[m[32m+    host = os.getenv("HLU_WEBHOOK_BIND","")[m
[32m+[m[32m+    port = int(os.getenv("HLU_WEBHOOK_PORT","0") or 0)[m
[32m+[m[32m+    if not host or not port:[m
[32m+[m[32m+        print("[TankScore] Webhook disabled (HLU_WEBHOOK_BIND/PORT not set).")[m
[32m+[m[32m+        return[m
[32m+[m[32m+    def _run():[m
[32m+[m[32m+        uvicorn.run(webhook_app, host=host, port=port, log_level="info")[m
[32m+[m[32m+    th = threading.Thread(target=_run, daemon=True, name="hlu-webhook")[m
[32m+[m[32m+    th.start()[m
[32m+[m[32m+    print(f"[TankScore] Webhook listening on http://{host}:{port}/event")[m
[32m+[m[32m+[m
[32m+[m[32m+@tasks.loop(seconds=1.0)[m
[32m+[m[32m+async def tick_scores():[m
[32m+[m[32m+    engine.tick()[m
[32m+[m[32m+    # could update a live message here later[m
